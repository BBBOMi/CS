# 소프트웨어 공학

## 1. 소프트웨어 고장률 곡선

1. 초기 : 설계 오류 및 제작 오류로 인한 고장률
2. 중기 : 유지보수하는 시점에서 난다. 수정으로 인한 다른 오류를 생성할 수 있다.
3. 말기 : 이전에 발견되지 않은 오류가 시간이 지날수록 점차적으로 발견되고 이로 인한 고장이 발생되므로 고장률은 증가하게 된다.

## 2. 소프트웨어의 위기(문제점)

* 소프트웨어 규모가 커지면서 복잡해지고 이로 인한 전체 개발 비용이 증대했다.
* 기존 소프트웨어의 유지보수가 힘들기 때문에 유지보수 비용이 증대했다.
* 기술적인 면보다는 관리적인 면이 증대되었다.
* 개발 기간의 지연 및 하드웨어 가격을 초과하는 소프트웨어 개발 비용이 증가했다.
* 소프트웨어 개발 속도가 하드웨어의 개발 속도를 따라가지 못해 사용자들의 요구사항을 감당할 수 없다.
* 개발 요청자와 개발자 간의 대화 단절 상태가 많아졌다.
* 스프트웨어의 성능 및 신뢰성이 부족하다.
* 새로운 개발 도구의 품질을 평가할 수 있는 표준이 없다.
* 개발 인력의 부재 및 그로 인한 인건비가 상승했다.

## 3. 소프트웨어 생명주기

* 소프트웨어를 개발하는 절차 및 단계의 반복 현상

* 생명 주기(SDLC)는 소프트웨어 개발의 기본 골격

  ### 3-1. 정의 단계

  * 타당성 검토 단계
    * 생명주기의 첫 단계로 프로젝트를 개발하기 위한 제반 여건 및 타당성 파악이 주목적이며 기술적 타당성, 경제적 타당성, 법적 타당성을 고려해야 한다.
  * 프로젝트 계획 단계
    * 소프트웨어를 개발하는데 필요한 모든 사항(비용 및 자원)들을 준비하는 단계이다.
  * 요구분석 단계
    * 개발할 소프트웨어의 문제 영역을 사용자에게 얻어내어 분석하는 단계이다.

  ### 3-2. 개발 단계

  * 설계 단계
    * 절차 구조, 알고리즘, 자료 구조, 구조도 등을 작성하여 프로그램을 쉽게 구현할 수 있도록 하는 단계
    * 자연 언어와 프로그램 설계용 언어를 사용한다.
    * 전체 생명주기 단계중 오류가 가장 많은 단계(45%)이다.
  * 구현 단계
    * 설계 단계에서 작성된 문서를 기초로 하여 컴퓨터 처리가 가능한 프로그램 언어로 코딩하고 번역하는 단계이다.
  * 검사 단계
    * 프로그램으로 구현된 소프트웨어를 대상으로 오류를 찾아 수정하는 단계이다.

  ### 3-3. 유지 보수 단계

  * 개발된 소프트웨어의 품질을 유지하기 위한 노력
  * 소프트웨어 생명주기 단계 중에 가장 많은 시간과 비용이 투입된다.
  * 하자 보수, 기능 개선, 예방 조치, 환경 적응

## 4.  폭포수(Waterfall, 전통적인) 모델

![img](http://cfile28.uf.tistory.com/image/22380B3854A6B532178311)

* 현재까지 가장 널리 사용되는 전통적인 모형
* 단계적 생명주기
* 단계별로 분명히 매듭짓고 그 다음 단계를 진행하자는 것이다.
* 각 단계에서 발생되는 오류는 다음 단계로 갈수록 오류가 증폭되므로 완성 단계에서는 걷잡을 수 없는 오류가 발생할 수 있다.
* 하지만 오류 없이 다음 단계로 진행하는 것은 현실적으로 불가능하다.


* 모델의 적용 경험과 성공 사례가 많다.
* 소프트웨어 개발 과정의 각 단계가 선형 순차적으로 진행된다.
* 가장 오래되고 널리 사용된 방법이다.(전통적인 기법)
* 단계별 산출물이 명확하다.(명확성 강조)
* 두 개 이상의 과정이 병렬/병행 수행되거나 이전 단계로 넘어가는 경우가 없다.
* 개발 과정 중에 발생하는 새로운 요구나 경험을 설계에 반영하기 힘들다.

## 5. 프로토 타입(Prototype) 모델

![img](http://cfile9.uf.tistory.com/image/2750F63E54A76DAA2AC0E4)

* 완성될 소프트웨어의 일부를 미리 제작하여 사용자의 요구를 정확히 받아들이는 방법
* 사용자가 쉽게 요구사항을 제시할 수 있고, 치명적인 오류를 최소화할 수 있다.
* 불분명한 사용자의 요구를 받아들이기에 적당한 방식이다.
* 요구사항의 변경이 용이하다.
* 요구분석 중심의 개발 방법론이다.
* 사용자와 개발자간의 의사소통이 원할하지 못할 때 서로의 이해에 도움을 준다.
* 구축하고자 하는 시스템의 요구사항이 불명확한 경우 효과적이다.
* 요구분석 단계에서 개발하거나 개발된 프로토타입 소프트웨어를 활용한다.
* 최종 결과물이 나오기 전에 의뢰자가 최종 결과물의 일부 또는 모형을 볼 수 있다.
* 프로토타입은 발주자나 개발자 모두에게 공동의 참조 모델을 제공한다.
* 프로토타입은 구현 단계에서 구현 골격이 될 수 있다.
* 단가간에 개발해야 하므로 비효율적인 알고리즘이나 언어를 사용할 수 있다.
* 사용자의 자체 업무에 충실하지 못하고 미리 제작한 소프트웨어에 의존할 수 있다.
* 미리 개발된 소프트웨어를 이용할 경우 실제 소프트웨어와 차이가 생길 수 있다.
* 프로토타입 모형은 소프트웨어 생명주기에서 유지보수가 없어지고 개발 단계 안엥서 유지보수가 이루어지는 것으로 볼 수 있다.
* Brooks의 이론
  * 개발 일정이 지연된다고 해서 말기에 새로운 인력을 투입하면 일정이 더욱 지연된다.
  * 프로토타입은 폐기 처분하는 첫 번째 시스템이다.

## 6. 나선형(Spiral, 점증적) 모델

![img](https://mblogthumb-phinf.pstatic.net/20140218_259/seilius_1392697072484Bg2UG_PNG/SpiralModel.png?type=w2)

* Boehm이 제안한 대규모 프로젝트 개발에 적당하다.
* 소프트웨어 개발에 가장 현실적이고 바람직한 모형이다.
* 폭포수 모델과 프로토타입 모델의 장점만을 수용하였다.
* 사용자의 초기 요구사항에 근거한 위험 요소들을 관리 기술을 통해 해소하자는 모형이다.
* 위험 분석에 중점을 두어 프로토타입을 발전시킬 때 마다 점증적으로 소프트웨어를 개발하는 방법이다.
* 1단계 : 계획 수립 -> 위험 분석 -> 개발 -> 고객 평가(10% 완성)
* 2단계 : 계획 수립 -> 위험 분석 -> 개발 -> 고객 평가(34% 완성)
* 3단계 : 계획 수립 -> 위험 분석 -> 개발 -> 고객 평가(77% 완성)
* 4단계 : 계획 수립 -> 위험 분석 -> 개발 -> 고객 평가(87% 완성)
* 계획 수립(Planning) : 개발 목적, 수정 계획, 제약 조건 등을 설정한다.
* 위험 분석(Risk analysis) : 위험 요소 및 타당성을 분석하여 프로젝트의 추진 여부를 결정한다.
* 개발(Engineering) : 개선된 한 단계의 프로토타입을 개발한다.
* 고객 평가(Customer evaluation) : 개발된 프로토타입을 평가한다.
* 고객과의 의사소통을 통해 계획 수립과 위험 분석, 구축, 고객 평가의 과정을 거쳐 소프트웨어를 개발한다.
* 위험 분석 단계에서 기술과 관리의 위험 요소들이 하나씩 제거해 나감으로써 완성도 높은 소프트웨어을 만들 수 있다.
* 반복적인 작업을 수행하는 점증적 생명주기 모델이다.
* 위험 분석 중심의 개발 모형이다.
* 유지본수는 처리 절차에 포함되지 않는다.
* 비용이 많이 들거나 시간이 많이 소요되는 대규모 프로젝트나 큰 시스템을 구축할 때 유리하다.

## 7. 프로젝트 계획

1. 프로젝트 규모 파악
2. 프로젝트 계획의 목표
3. 프로젝트 계획 단계의 특징 : 개발 비용을 추정하고, 유지 보수 비용은 개발이 모두 끝난 후에 책정한다.
4. 외주 개발을 위한 제안서 평가 항목

## 8. CASE(Computer Aided Software Engineering)

* 소프트웨어를 개발하는 시점부터 요구분석, 설계, 개발, 유지보수에 이르기까지 소프트웨어의 생명주기 전반을 지원하는 프로그램 또는 소프트웨어 개발을 지원하는 자동화 도구 혹은 방법론의 결합

* 소프트웨어를 효율적으로 정확하고 신속하게 개발할 수 있도록 해준다.

* 차후에 소프트웨어를 수정하거나 유지보수할 때 아주 정확하게 수정해 주기도 한다.

* CASE의 가격이 매우 비싸고 분석가의 지원이 필요하다.

* 개발된 소프트웨어의 특정에 맞는 CASE를 선택하는 것은 매우 중요하다.

  ### 8-1. CASE 분류

  * 상위(Upper) CASE
    * 소프트웨어 생명주기의 전반부 과정을 지원한다.
    * 요구분석과 설계를 지원하며, 명세서와 문서를 작성한다.
    * PSL/PSA, SREM, SYSREM, FOUNDATION
  * 하위(Lower) CASE
    * 소프트웨어 생명주기의 하반부 과정을 지원한다.
    * 구현, 테스트를 지원하며 문서화하는 과정에 도움을 주는 여러 가지 도구를 포함한다.
    * 코드 생성기, 링커, 로더, 디버그 등이 있다.
    * 소프트웨어 생명주기의 전체 과정을 지원한다.
  * 통합(Integrate) CASE
    * 공통의 정보 저장소와 통일된 사용자 인터페이스를 사용하여 도구들을 통합한다.
    * POWERTOOLS, IEF, TAGS/IORL, TEAMWORK, PROMOD

  ### 8-2. 특징

  * 소프트웨어의 개발 과정을 자동화함으로써 생산성을 증대시키고자 하는 목적으로 개발되었다.
  * CASE는 소프트웨어 개발의 모든 단계에 걸쳐 일관된 방법론을 지원한다.
  * CASE를 사용함으로써 개발의 표준화를 지향하고, 자동화의 이점을 얻을 수 있다.
  * CASE의 툴 가격은 비싸지만 소프트웨어 개발 시 개발 비용이 절감된다.
  * 수정이 용이하고 정확하다.
  * 개발 과정의 속도를 향상시킨다.
  * 소프트웨어의 유지보수를 용이하게 수행할 수 있도록 해준다.
  * 소프트웨어의 생산성 문제를 해결할 수 있다.
  * 모듈의 재사용성이 향상된다.
  * 자동화된 검사를 통해 소프트웨어의 품질을 향상시킨다.
  * CASE툴들 간에 호환성이 없다.
  * 소프트웨어 부품의 재사용성을 향상시켜 준다.
  * 그래픽 등 다양한 소프트웨어 개발 모형을 지원한다.
  * 생명주기의 모든 단계를 연결시켜 주고 자동화시켜 준다.
  * 분석가의 지원이 절대적으로 필요하다.

## 9. COCOMO(Constructive Cost MOdel)

* 소프트웨어의 종류에 따라 다르게 책정되는 비용 산정 방정식을 이용하는 합리적인 방식

* B.Bohem이 제시한 원시 프로그램의 규모에 의한 비용 예측 모형

* 같은 규모의 프로그램이라도 그 성격에 따라 비용이 다르게 생성된다.

* 유연성이 높아 다양한 소프트웨어 측정에 적용시키기 적당하여 널리 통용되고 있다.

* 단순히 소프트웨어의 크기(KDSI)와 개발 모드(유기형, 준분리형, 내재형)에 의해 비용이 산출된다.

* 기본 모형으로는 계속 발전되고 변화하는 소프트웨어 개발 기술의 적용에는 적합하지 않기 때문에 계속 수정, 보완하고 있다.

* 기본(Basic), 중간(Intermediate), 세부(Detailed)형 모델로 구분한다.

  ### Basic COCOMO의 비용 산정 방정식

  ### 9-1. 유기형(Organic)

  * 회사 내부에서 개발된 중소 규모의 소프트웨어
  * 일괄처리나 과학 기술 계산용, 비즈니스 자료 처리용의 5만 라인 이하의 소프트웨어를 평가하는 유형
  * 업무용, 과학적, 사무 처리용

  ### 9-2. 준 분리형(Semi-detached)

  * 중 소 규모의 트랜잭션 처리 시스템이나 운영체제, 데이터 베이스 관리 시스템 등의 30만 라인 이하의 소프트웨어를 평가하는 유형
  * 컴파일러, 인터프리터, 워드프로세서

  ### 9-3. 내재형(Embedded)

  * 최대형 규모의 트랜잭션 시스템이나 운영체제 등의 소프트웨어를 평가하는 유형
  * DBMS, 운영체제, 통신용

## 10. 일정 계획 방법론

* 프로젝트 개발 기간의 지연을 방지하고 계획대로 진행되게 하기 위한 방법

  ### 10-1. PERT(Program Evaluation and Review Technique)

  ![img](https://upload.wikimedia.org/wikipedia/commons/b/b9/Pert_chart_colored.gif)

  * 복잡한 프로젝트를 평가하고 관리하기 위해 시작부터 종료까지의 모든 단계를 원, 직선, 화살표를 이용하여 전체 공정의 흐름을 일목요연하게 표시하는 방법이다.
  * 모든 프로젝트를 서로 연관된 소 작업으로 분류하고 이들의 시작부터 끝나는 지점까지의 관계를 화살표로 그려 개발 기간을(일정 계획)을 예측한다.

  ### 10-2. CPM(Critical Path Method)

  ![img](https://upload.wikimedia.org/wikipedia/commons/c/cd/SimpleAONwDrag3.png)

  * PERT와 거의 비슷한 관리 기법
  * 주 공정(Critical Path)에 비중을 둔다.
  * 주 공정을 나타내는 경로의 흐름이 지연되면 다른 공정도 모두 지연시켜 주 공정이 완전히 해소되면 진행한다.
  * 개발 기간(일정 계획)을 하나의 숫자로 예측하는 방법
  * CPM을 이용한 일정 계획 순서
    * 프로젝트의 규모를 추정한다.
    * 각 단계에 필요한 작업들을 분하한다.
    * 각 작업의 상호 의존 관계를 CPM 네트워크로 나타낸다.
    * 일정 계획을 간트 차트로 나타낸다.
  * 프로젝트 개발 단계 간의 작업 관계를 나타내며 개발 기간의 최장 경로(임계 경로)를 파악 할 수 있다.
  * 노드에서 작업을 표시하고 간선(화살표)은 작업 사이의 전후 의존 관계를 나타낸다.
  * 박스 모양의 노드는 프로젝트 개발 중간 지점을 뜻하는 이정표로 이 노드에 예상 완료 시간을 표시한다.
  * 한 이정표에서 다른 이정표에 도달하기 전에 이전 작업이 모두 완료되지 않으면 다음 작업으로 진행할 수 없다.
  * 병행 작업이 가능하도록 계획화 할 수 있으며 이를 위한 자원 할당도 가능하다.
  * 다른 일정 계획안을 시뮬레이션할 수 있다.
  * 비용 측정은 하지 않는다.
  * 정확한 일정을 예측할 수는 없다.

## 11. 자료 흐름도(DFD : Data Flow Diagram)

![img](http://cjmyun.tripod.com/Knowledgebase/DFD.files/dfd1.gif)

* 자료가 소프트웨어 내의 각 절차를 따라 흐르면서 변화는 과정을 도형화시키는 방법

* 사용자 요구를 넓은 시각에서 분석하는 도구다

* 설계 단계에서 기본적으로 사용된다는 점에서 가장 많이 사용하는 방법이다.

  ![img](http://cfile7.uf.tistory.com/image/21513842570C3F6339430A)

* 시스템 내의 모든 자료 흐름도는 4가지 기본 기호로 표시한다.

* 어떤 처리가 출력 자료를 산출하기 위해선 반드시 입력 자료가 존재해야 한다.

* 자료 흐름은 처리를 거쳐 변환될 때마다 새로운 이름을 부여한다.

* 상위 단계의 처리와 하위 자료 흐름도는 서로 일치되어야 한다.

* 구성 요소 중 종착지는 원으로 표시한다.

* 자료 흐름도의 최하위 처리는 소단위 명세서를 가진다.

* 각각의 처리는 개별적으로 상세화해야 한다.

* DFD 작성 시 정확한 이름을 사용하고 자료 보존 법칙을 준수한다.

* 자료 흐름도는 한 페이지 단위로 그린다.

* 한 페이지에 2~3단계가 적당하다.

* 한 페이지는 12개 이내의 처리가 적당하다.

* 각 단계는 6~7개의 처리가 적당하다.

* 맨 마지막 처리는 프로그램이 가능한 수준으로 상세화한다.

* DFD 세분화 : 각 단계에서 한 개의 버블이 상세 분석되면 또다시 세분화된 DFD가 생성된다.

* 세분화가 깊어질수록 소프트웨어 설계와 프로그램 코딩이 쉽게 구현될 수 있다.

## 12. 자료 사전(DD : Data Dictionary)

* DFD의 대상이 되는 자료의 내용을 구체적으로 명시한 것
* Field, Attribute 등이 정의된다.
* 보통 DFD에서 사용되는 파일의 레코드를 설계하기 쉽게 표현한 문서이다.
* 자료를 설명하고 있는 데이터를 Mata Data라고 한다.

![img](http://cfile23.uf.tistory.com/image/2258E840570C401032FDB2)

## 13. 소단위 명세서(Mini-spec)

* DFD에서 각 버블이 수행할 기능을 자연 언어로 간단하게 작성하는 작업이다.
* 프로젝트 규모가 크고 복잡할 경우에 주로 작성된다. 규모가 작은 프로젝트일 경우에는 대부분 생략한다.
* 실제 프로그램 코드와 비슷하게 작성되기도 하는 미니 명세서는 버블들의 설명을 1~2 페이지 정도의 소규모 분량으로 작성한다.
* 미니 명세서는 프로그램 설계 언어(PDL)를 사용한 논리적 절차를 포함하기도 한다.

## 14. 요구분석용 자동화 도구(CASE)

* ​

  ### 14-1. SADT(Structure Analysis & Design Technique)

  * 대규모 프로젝트용 요구분석 방법론이다.
  * 구조적인 도형 표기와 그것을 효율적으로 수행하기 위핸 설계 방법으로 이루어져 있다.
  * 요구분석과 설계 분석, 설계 명세서를 동시에 표현할 수 있는 수동적인 도구이다.

  ### 14-2. BS(Brain Storming)

  * 요구분석 시에 사용자의 의견을 듣는 개발자의 자세 및 규칙
  * 비판 금지
  * 자유분방
  * 다수 환영
  * 연쇄 개선

  ### 14-3. PSL/PSA(Program Statement Language / Program Statement Analysis)

  * 요구분석용 자동화 도구
  * 요구분석에 필요한 내용을 PSL이란 기술 언어를 사용하여 작성한 뒤 PSA에 입력하면 PSA는 분석 데이터 베이스에 저장하고 있는 자료를 분석하여 최적의 요구 명세서를 자동으로 출력해준다.

  ### 14-4. SREM(Software Requirement Engineering Methodology), RSL/REVS

  * 실시간 요구분석 방법론 및 자동화 도구
  * 도형 표기법 R-Net(Requirements Network)과 기술용 언어 RSL(Requirements Statement Language)로 작성된 요구분석의 기본 자료를 REVS(Requirements Statement & Validation System)에 입력하면 REVS는 입력된 RSL을 번역하여 요구분석 데이터 베이스에서 RSL에 요구된 사항대로 요구 명세서를 자동으로 출력해준다.

## 15. 모듈화(Modularization)

* 구현, 컴파일, 설계는 독립적으로 수행된다.
* 실행은 종속적으로 수행된다.
* 모듈은 다른 모듈을 호출할 수도, 호출당할 수도 있다.
* 모듈 호출 시 매개 변수를 전달하거나 전달받을 수 있다.
* 기본 라인 수는 100라인 이내가 적당하다.
* 모듈을 찾아서 실행하는 시간은 느리다.
* 단위 프로그램을 독립적으로 설계할 수 있기 때문에 설계가 용이하다.
* 모듈만을 구분하면 되므로 프로그램의 복잡도를 감소시킨다.
* 다른 모듈에 영향을 주지 않을 수 있으므로 수정이 용이하다.
* 모듈의 기본 요소(속성)
  * 입력 요소 : 자료를 받아들이는 기능이다.
  * 출력 요소 : 자료를 내보내는 기능이다.
  * 기능 요소 : 모듈의 처리 결과, 모듈의 능력이다.
  * 기관 요소 : 알고리즘
  * 내부 자료 요소 : 내부 변수

## 16. 결합도(Coupling)

* **결합도 평가는 두 모듈 간의 관계성(상호 의존성)의 척도로, 약할수록 좋은 결합이다.**

  ### 16-1. Data Coupling(자료 결합도), 약 결합도

  * 두 모듈 간의 인터페이스가 자료 요소만으로 구성된 가장 좋은 결합도
  * 실인수와 가인수의 번지가 독립적으로 사용된다.
  * CALL BY VALUE 기법으로 결합된 모듈
  * 하나의 모듈(함수)이 매개 변수(파라미터나 인수)를 통해 다른 모듈에게 데이터를 넘겨주고 호출받은 모듈은 받은 데이터에 대한 처리 결과를 다시 돌려주는 유형의 모듈 결합도이다.

  ### 16-2. Stamp Coupling(구조 결합도)

  * 두 모듈 간에 같은 레코드를 부분적으로 공유한다.
  * 모듈 간 독립성은 유지되지만, 같은 작업 대상인 자료로 묶인 결합을 의미한다.
  * 모듈 간의 인터페이스가 배열이나 레코드 등의 자료 구조로 전달되는 경우이다.
  * 두 모듈이 동일한 자료 구조를 조회하는 경우의 결합성이다.
  * 포맷이나 구조의 변화는 그것을 조회하는 모든 모듈 및 변화되는 필드를 실제로 조회하지 않는 모듈까지도 영향을 미치게 된다.

  ### 16-3. Control Coupling(제어 결합도)

  * 호출 모듈에서 전달된 자료에 의해서 운용되는 피 호출 모듈의 관계
  * 모듈 간에는 제어 변수로 종속적인 관계를 가진다.

  ### 16-4. Extern Coupling(외부 결합도)

  * 외부 변수에 의해 영향을 받는 두 모듈이 결합된 관계
  * 모듈 내부에서 외부 변수를 사용하게 되면 외부 변수에 의해 두 모듈이 결합력이 높아지며 경우에 따라서는 부작용이 발생할 수도 있다.

  ### 16-5. Common Coupling(공통 결합도)

  * 공유되는 공통 데이터 영역을 여러 모듈이 사용하는 모듈 관계
  * 실인수와 가인수는 같은 번지를 공유하므로 가인수의 값이 변하면 실인수의 값도 변하는 형태
  * 피호출 모듈을 수정할 때 실인수 값의 영향을 항상 고려해야 하는 불편함이 있는 결합
  * 공통 결합은 부득이한 경우가 아니면 사용하지 않는 것이 좋다.

  ### 16-6. Content Coupling(내용 결합도), 강 결합도

  * 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 참조하는 형태의 결합
  * 고급 언어에서는 사용되지 않고 저급 언어인 어셈블리어에서 가끔 사용되는 결합이다.
  * 두 모듈은 형식적으로 분리되어 있기 때문에 모듈을 수정할 경우에는 두 모듈을 항상 같이 고려해야 하는 가장 안 좋은 결합이다.

* 결합도의 강, 약

```
- Data Coupling(자료 결합도) = 결합도 약하다.
- Stamp Coupling(구조 결합도)
- Control Coupling(제어 결합도)
- Extern Coupling(외부 결합도)
- Common Coupling(공통 결합도)
- Content Coupling(내용 결합도) = 결합도 강하다.
```

## 17. 응집도(Cohesion)

* 한 모듈을 이루고 있는 각 요소(명령어)들이 공통적인 목표 달성을 위하여 어느 정도의 관련성(상호 의존성)이 있는가를 파악하는 척도이다.

* **결합도는 약할수록, 응집도는 강할수록 좋다.**

  ### 17-1. Coincidental Cohension(우연적 응집도), 약 응집도

  * 모듈 내부의 루틴들이 뚜렷한 관계 없이 묶인 경우
  * 응집도가 가장 약하고 가장 좋지 않은 모듈 설계
  * 서로 간에 의미 있는 어떠한 연관 관계도 지니지 않은 기능 요소로 구성
  * 서로 다른 기능을 수행하는 경우의 응집도

  ### 17-2. Logical Cohension(논리적 응집도)

  * 모듈 내부의 루틴들이 같은 범주에 속하는 기능끼리 묶인 경우
  * 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 하나의 모듈로 형성된다.

  ### 17-3. Temporal Cohension(시기적 응집도)

  * 모듈 내부의 루틴들이 시간상으로 수행 시가가 같은 기능끼리 존재하는 경우
  * 변수를 초기화한다든지 파일을 일괄적으로 Open, Close 하는 작업

  ### 17-4. Procedural Cohension(절차적 응집도)

  * 모듈 내부의 루틴들이 수행 시기에 순위가 있는 기능끼리 존재하는 경우
  * 순서도(Flow Chart) 등의 일부를 모듈화 하는 작업이 속한다.

  ### 17-5. Communication Cohension(통신적, 정보적 응집도)

  * 모듈 내부의 루틴들이 작업 대상이 같은 기능끼리 존재하는 경우나 동일한 입축력을 사용하는 작업들끼리 모인 경우
  * 하나의 파일을 대상으로 갱신 작업을 하는 루틴끼리 묶인 경우

  ### 17-6. Sequentiial Cohension(순차적 응집도)

  * 모듈 내부의 루틴들이 이전의 명령어(활동)로부터 나온 출력 결과(자료)를 그 다음 명령어(활동)의 입력 자료로 사용하는 경우

  ### 17-7. Functional Cohension(기능적, 함수적 응집도), 강 응집도

  * 모듈 내부가 하나의 단일 기능으로 존해는 경우
  * 프로그램 언어에서 지원받는 라이브러리가 이에 속한다.
  * 응집도 중 가장 강하고 좋은 모듈

* 응집도의 강,약

```
- Coincidental Cohension(우연적 응집도) = 응집도 약하다.
- Logical Cohension(논리적 응집도)
- Temporal Cohension(시기적 응집도)
- Procedural Cohension(절차적 응집도)
- Communication Cohension(통신적, 정보적 응집도)
- Sequentiial Cohension(순차적 응집도)
- Functional Cohension(기능적, 함수적 응집도) = 응집도 강하다.
```

## 18. HIPO(Hierarchy Plus Input Process Output)

* 프로그램을 기능 위주로  문서화 하는 하향식 설계 기법
* 입력, 처리, 출력으로 구성되어 시각적으로 알아보기 쉽게 표현할 수 있다.
* 구조화된 방법으로 구현될 수 있도록 한다.
* 시스템의 기능을 여러 개의 고유 모듈들로 분할하여 이들 간의 인터페이스를 계층 구조로 표현한 도형, 도면이다.

![img](http://cfile23.uf.tistory.com/image/264D4846570C40A1245235)

* 분석 및 설계 도구로 사용된다.
* 기본 시스템 모델은 입력, 처리, 출력으로 구성된다.
* 하향식 개발에 적당하다.
* 문서가 보기 좋게 체계화 된다.(보고서 용)
* 기능과 자료의 관계를 동시에 표현할 수 있다.
* 수정 및 유지보수가 용이하다.
* 소규모 프로젝트에 적당하다.

## 19. 자료 흐름 설계 과정

1. 정보 흐름의 유형을 설정한다.
2. 흐름의 경계(Flow Boundaries)를 표시한다.
3. DFD를 프로그램 구조로 사상한다. -> 변환 사상
4. 제어 계층을 분해시켜서 정의한다.
5. 경험적 방법으로 구체화시킨다.

## 20. 자료 구조 중심 설계 방법론

### 20-1. DSSD 방법론(Warnier-Orr 기법)

* 자료 구조 지향 설계 방법
* 출력 자료를 중심으로 입력 자료를 설계하고 제어 구조도 설계하는 방법

1. 출력 자료 정의 : 출력할 자료를 파악하여 배열한다.
2. 논리적 레코드 정의 : 출력할 레코드의 구조를 정의한다.
3. 사건 분석 : 출력할 레코드 항목을 기준으로 입력 항목을 정의한다.
4. 물리적 레코드 정의 : 입력할 레코드의 구조를 정의한다.
5. 논리적 절차 정의 : 입력, 처리, 출력 모듈로 구분하여 Warnier-Orr 도표를 그린다.
6. 물리적 절차 정의 : 명시된 Warnier-Orr 도표를 보고 알고리즘을 기술한다.

### 20-2. JSD 방법론(Jackson 기법)

* 프로그램의 입력과 출력 자료의 구조를 대응시켜서 설계하는 자료 구조 지향 설계 방법
* 자료 구조를 정의하면서 제어 구조를 유도하는 방식

1. 자료 구조 정의 : 입출력 구조를 정의하여 일치되지 않는 부분을 루틴으로 모듈화하고 일치하는 부분은 입력과 출력 루틴으로 모듈화한다.
2. 구조도 작성 : 입력, 처리, 출력으로 분류하여 잭슨 표기법으로 구조도를 세분화하여 작성한다.
3. 연산 목록 작성 : 구조도를 보고 필요한 제어 구조를 명시한다.
4. 구조문 작성 : 명시된 제어 구조를 보고 알고리즘을 기술한다.

## 21. 객체지향 분석

## 22. 객체지향 설계

