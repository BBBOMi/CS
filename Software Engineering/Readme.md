# 소프트웨어 공학

## 1. 소프트웨어 공장률 곡선

1. 초기 : 설계 오류 및 제작 오류로 인한 고장률
2. 중기 : 유지보수하는 시점에서 난다. 수정으로 인한 다른 오류를 생성할 수 있다.
3. 말기 : 이전에 발견되지 않은 오류가 시간이 지날수록 점차적으로 발견되고 이로 인한 고장이 발생되므로 고장률은 증가하게 된다.

## 2. 소프트웨어의 위기(문제점)

* 소프트웨어 규모가 커지면서 복잡해지고 이로 인한 전체 개발 비용이 증대했다.
* 기존 소프트웨어의 유지보수가 힘들기 때문에 유지보수 비용이 증대했다.
* 기술적인 면보다는 관리적인 면이 증대되었다.
* 개발 기간의 지연 및 하드웨어 가격을 초과하는 소프트웨어 개발 비용이 증가했다.
* 소프트웨어 개발 속도가 하드웨어의 개발 속도를 따라가지 못해 사용자들의 요구사항을 감당할 수 없다.
* 개발 요청자와 개발자 간의 대화 단절 상태가 많아졌다.
* 스프트웨어의 성능 및 신뢰성이 부족하다.
* 새로운 개발 도구의 품질을 평가할 수 있는 표준이 없다.
* 개발 인력의 부재 및 그로 인한 인건비가 상승했다.

## 3. 소프트웨어 생명주기

* 소프트웨어를 개발하는 절차 및 단계의 반복 현상

* 생명 주기(SDLC)는 소프트웨어 개발의 기본 골격

  ### 3-1. 정의 단계

  * 타당성 검토 단계
    * 생명주기의 첫 단계로 프로젝트를 개발하기 위한 제반 여건 및 타당성 파악이 주목적이며 기술적 타당성, 경제적 타당성, 법적 타당성을 고려해야 한다.
  * 프로젝트 계획 단계
    * 소프트웨어를 개발하는데 필요한 모든 사항(비용 및 자원)들을 준비하는 단계이다.
  * 요구분석 단계
    * 개발할 소프트웨어의 문제 영역을 사용자에게 얻어내어 분석하는 단계이다.

  ### 3-2. 개발 단계

  * 설계 단계
    * 절차 구조, 알고리즘, 자료 구조, 구조도 등을 작성하여 프로그램을 쉽게 구현할 수 있도록 하는 단계
    * 자연 언어와 프로그램 설계용 언어를 사용한다.
    * 전체 생명주기 단계중 오류가 가장 많은 단계(45%)이다.
  * 구현 단계
    * 설계 단계에서 작성된 문서를 기초로 하여 컴퓨터 처리가 가능한 프로그램 언어로 코딩하고 번역하는 단계이다.
  * 검사 단계
    * 프로그램으로 구현된 소프트웨어를 대상으로 오류를 찾아 수정하는 단계이다.

  ### 3-3. 유지 보수 단계

  * 개발된 소프트웨어의 품질을 유지하기 위한 노력
  * 소프트웨어 생명주기 단계 중에 가장 많은 시간과 비용이 투입된다.
  * 하자 보수, 기능 개선, 예방 조치, 환경 적응

## 4.  폭포수(Waterfall, 전통적인) 모델

![img](http://cfile28.uf.tistory.com/image/22380B3854A6B532178311)

* 현재까지 가장 널리 사용되는 전통적인 모형
* 단계적 생명주기
* 단계별로 분명히 매듭짓고 그 다음 단계를 진행하자는 것이다.
* 각 단계에서 발생되는 오류는 다음 단계로 갈수록 오류가 증폭되므로 완성 단계에서는 걷잡을 수 없는 오류가 발생할 수 있다.
* 하지만 오류 없이 다음 단계로 진행하는 것은 현실적으로 불가능하다.


* 모델의 적용 경험과 성공 사례가 많다.
* 소프트웨어 개발 과정의 각 단계가 선형 순차적으로 진행된다.
* 가장 오래되고 널리 사용된 방법이다.(전통적인 기법)
* 단계별 산출물이 명확하다.(명확성 강조)
* 두 개 이상의 과정이 병렬/병행 수행되거나 이전 단계로 넘어가는 경우가 없다.
* 개발 과정 중에 발생하는 새로운 요구나 경험을 설계에 반영하기 힘들다.

## 5. 프로토 타입(Prototype) 모델

![img](http://cfile9.uf.tistory.com/image/2750F63E54A76DAA2AC0E4)

* 완성될 소프트웨어의 일부를 미리 제작하여 사용자의 요구를 정확히 받아들이는 방법
* 사용자가 쉽게 요구사항을 제시할 수 있고, 치명적인 오류를 최소화할 수 있다.
* 불분명한 사용자의 요구를 받아들이기에 적당한 방식이다.
* 요구사항의 변경이 용이하다.
* 요구분석 중심의 개발 방법론이다.
* 사용자와 개발자간의 의사소통이 원할하지 못할 때 서로의 이해에 도움을 준다.
* 구축하고자 하는 시스템의 요구사항이 불명확한 경우 효과적이다.
* 요구분석 단계에서 개발하거나 개발된 프로토타입 소프트웨어를 활용한다.
* 최종 결과물이 나오기 전에 의뢰자가 최종 결과물의 일부 또는 모형을 볼 수 있다.
* 프로토타입은 발주자나 개발자 모두에게 공동의 참조 모델을 제공한다.
* 프로토타입은 구현 단계에서 구현 골격이 될 수 있다.
* 단가간에 개발해야 하므로 비효율적인 알고리즘이나 언어를 사용할 수 있다.
* 사용자의 자체 업무에 충실하지 못하고 미리 제작한 소프트웨어에 의존할 수 있다.
* 미리 개발된 소프트웨어를 이용할 경우 실제 소프트웨어와 차이가 생길 수 있다.
* 프로토타입 모형은 소프트웨어 생명주기에서 유지보수가 없어지고 개발 단계 안엥서 유지보수가 이루어지는 것으로 볼 수 있다.
* Brooks의 이론
  * 개발 일정이 지연된다고 해서 말기에 새로운 인력을 투입하면 일정이 더욱 지연된다.
  * 프로토타입은 폐기 처분하는 첫 번째 시스템이다.

## 6. 나선형(Spiral, 점증적) 모델

![img](https://mblogthumb-phinf.pstatic.net/20140218_259/seilius_1392697072484Bg2UG_PNG/SpiralModel.png?type=w2)

* Boehm이 제안한 대규모 프로젝트 개발에 적당하다.
* 소프트웨어 개발에 가장 현실적이고 바람직한 모형이다.
* 폭포수 모델과 프로토타입 모델의 장점만을 수용하였다.
* 사용자의 초기 요구사항에 근거한 위험 요소들을 관리 기술을 통해 해소하자는 모형이다.
* 위험 분석에 중점을 두어 프로토타입을 발전시킬 때 마다 점증적으로 소프트웨어를 개발하는 방법이다.
* 1단계 : 계획 수립 -> 위험 분석 -> 개발 -> 고객 평가(10% 완성)
* 2단계 : 계획 수립 -> 위험 분석 -> 개발 -> 고객 평가(34% 완성)
* 3단계 : 계획 수립 -> 위험 분석 -> 개발 -> 고객 평가(77% 완성)
* 4단계 : 계획 수립 -> 위험 분석 -> 개발 -> 고객 평가(87% 완성)
* 계획 수립(Planning) : 개발 목적, 수정 계획, 제약 조건 등을 설정한다.
* 위험 분석(Risk analysis) : 위험 요소 및 타당성을 분석하여 프로젝트의 추진 여부를 결정한다.
* 개발(Engineering) : 개선된 한 단계의 프로토타입을 개발한다.
* 고객 평가(Customer evaluation) : 개발된 프로토타입을 평가한다.
* 고객과의 의사소통을 통해 계획 수립과 위험 분석, 구축, 고객 평가의 과정을 거쳐 소프트웨어를 개발한다.
* 위험 분석 단계에서 기술과 관리의 위험 요소들이 하나씩 제거해 나감으로써 완성도 높은 소프트웨어을 만들 수 있다.
* 반복적인 작업을 수행하는 점증적 생명주기 모델이다.
* 위험 분석 중심의 개발 모형이다.
* 유지본수는 처리 절차에 포함되지 않는다.
* 비용이 많이 들거나 시간이 많이 소요되는 대규모 프로젝트나 큰 시스템을 구축할 때 유리하다.

## 7. 프로젝트 계획

## 8. CASE(Computer Aided Software Engineering)

## 9. Basic COCOMO 비용 산정 방정식

## 10. 일정 계획 방법론

## 11. 자료 흐름도(DFD)

## 12. 자료 사전(DD)

## 13. 소단위 명세서

## 14. 요구분석용 자동화 도구(CASE)

## 15. 모듈화

## 16. 결합도

## 17. 응집도

## 18. HIPO

## 19. 자료 흐름 설계 과정

## 20. 자료 구조 중심 설계 방법론

## 21. 객체지향 분석

## 22. 객체지향 설계

