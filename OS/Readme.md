# 운영 체제

## 1. 제어 프로그램(Kernel)

* 하드웨어를 제어하는 프로그램
* 메모리, CPU, 단말기, 프린터 등 시스템의 자원 활용도를 높이기 위해 스케줄링과 자료 관리를 하는 핵심 요소이다.

## 2. 명령어 해석기(Shell)

* 사용자의 명령을 입력받아 시스템 기능을 수행하는 명령 해석기
* 사용자와 시스템 간의 인터페이스를 담당하는 프로그램이다.

## 3. 매크로

* 어셈블리어를 사용하기 쉽도록 명령어들을 문자로 치환하여 확장해 준다.

* 메크로 라이브러리는 여러 프로그램에서 공통적으로 자주 사용되는 매크로들을 모아 놓은 라이브러리다.

* 매크로는 일정의 문자열 치환과 같이 사용된 횟수만큼 명령어를 생성, 삽입하여 실행한다.

* 매크로 내에 또 다른 매크로를 정의할 수 있다.

  ### 3-1. 매크로 프로세서의 기본 기능

  1. 매크로 정의 인식 : 매크로를 정의한 부분의 시작과 종료를 파악한다.
  2. 매크로 정의 저장 : 매크로 프로세서는 매크로명과 정의된 내용을 매크로 호출시 확장하기 위해 저장한다.
  3. 매크로 호출 인식 : 매크로가 확장하기 위한 준비가 되어 있는지 확인한다.
  4. 매크로 확장 및 인수 : 매크로명이 있는 원시 프로그램 위치에 저장된 내용과 인수를 치환한다.

## 4. 로더(Loader)

* 목적 프로그램(기계어로 구성된 파일)을 실행 가능한 파일로 변환하기 위해 주기억 장소를 할당(Allocation) 하거나, 여러 개의 목적 프로그램을 연계 편집하여 CPU가 처리될 수 있는 프로그램으로 변환한다.

* 프로그램을 실행하기 위하여 프로그램을 보조 기억 장치로부터 컴퓨터의 주기억 장치에 올려 놓는 것을 좁은 의미의 로더

* 목적 프로그램들끼리 연결(Linking)시키거나 주기억 장치를 재배치(Relocation)하는 등의 포괄적인 작업을 하게 되는 것을 넓은 의미의 로더

  ### 4-1. 로더의 기능

  * 할당 -> 연결 -> 재배치 -> 적재 순으로 진행된다.

  1. 할당(Allocation) : 목적 프로그램이 실행될 주기억 장치(RAM)의 공간을 확보한다.
  2. 연결(Linking) : 여러 개의 독입적인 모듈을 연결한다.
  3. 재배치(Relocation) : 프로그램이 주기억 장치 공간 안에서 위치를 변경할 수 있게 한다.
  4. 적재(Loading) : 프로그램 전체를 주기억 장치에 한 번에 적재하게 하거나, 실행 시 필요한 일부분만을 차례로 적재하게 한다.

  ### 4-2. 로더의 종류

  1. Compile and Go 로더 : 번역 프로그램과 로더가 하나로 구성되어 번역 프로그램이 로더의 역할까지 담당하는 방식
  2. 절대 로더 : 로더의 역할이 축소되어 가장 간단한 프로그램으로 구성된 것으로 기억 장소 할당이나 연결을 프로그래머가 직접 지정하는 방식이다.
  3. 직접 연결 로더 : 로더가 할당, 연결, 재배치, 적재를 모두 수행하는 일반적인 형태이다.
  4. 기타 로더 : Binding 로더, Module 로더, 동적 적재 로더(CPU가 현재 사용중인 부분만 적재하고 미사용 중인 프로그램은 보조 기억 장치에 저장해 두는 방식, Load-On-Call)

## 5. 운영체제의 성능 평가 기준

1. 처리량(Throughput)
2. 반환 시간(Turn around Time)
3. 신뢰도(Reliablility)
4. 사용 가능도(Availability)

## 6. 디스패치(Dispatch), 스풀(Spool), 버퍼링(Buffering)

1. 디스패치
   * 준비 상태에 있는 여러 프로세스중 프로세스를 선정하여 CPU를 할당하는 시점
2. 스풀
   * 프로그램과 이를 이용하는 I/O 장치와의 속도 차를 극복하기 위한 장치로 대부분 하드 디스크가 중재한다.
3. 버퍼링
   * CPU와 입출력 장치와의 속도 차이를 줄이기 위해 메모리가 중재한다.

## 7. 인터럽트(Interrupt)

* 프로세스가 수행 중에 다른 프로세스를 수행하기 위하여 현재 수행중인 프로세스를 중단하거나 외부 입력 장치에 의해 프로세스가 중단되는 상태

* 현재 프로세스를 중단시키는 모든 행위

  ### 7-1. 인터럽트 처리 순서

  1. 인터럽트가 발생하면 운영체제가 제어권을 받는다.
  2. 운영체제는 인터럽트 받은 현태의 프로세스 상태를 저장한다.
  3. 운영체제는 인터럽트의 정보를 분석하여 지정되어 있는 루틴으로 제어권을 넘겨준다.
  4. 인터럽트 처리 루틴이 인터럽트를 처리한다.
  5. 인터럽트가 걸렸던 이전 프로세스의 상태로 복구된다.
  6. 인터럽트가 걸렸던 시점 이후부터 프로세스가 실행된다.

  ### 7-2. 인터럽트의 종류

  1. SVC(SuperVisor Call) 인터럽트
     * 운영체제의 감시 프로그래믈 호출하면 발생
     * 사용자로부터 운영체제를 보호하거나 입출력 수행 루틴 호출, 기억 장치 할당, 오퍼레이터와의 대화등을 위해 발생하는 인터럽트이다.
  2. 입출력(I/O) 인터럽트
     * 하드웨어적 인터럽트로 입출력 채널 확인, 준비, 할당, 완료 시에 발생한다.
  3. 외부(External) 인터럽트
     * 인터럽트 시계에 의해 프로세스가 시간 할당량이 종료된 경우 발생한다.
  4. 재시작(Restart) 인터럽트
     * 자용자가 재시작을 하는 경우이다.
  5. 프로그램 검사(Program Check) 인터럽트
     * Overflow, Underflow 상태시, 나눗셈에서 분모가 0인 경우
  6. 기계 검사(Hardware Check) 인터럽트
     * 시스템의 기계 고장

## 8. 문맥 교환(Context Switching)

* CPU가 할당되는 프로세스를 변경하기 위하여 현재 CPU를 사용하여 실행되고 있는 **프로세서의 상태 정보를 저장**하고 제어권을 인터럽트 서비스 루틴(ISR)에게 넘기는 작업

  ### 8-1. 문맥 교환의 위치

  1. 프로그램 실행 : 인터럽트 발생
  2. 프로그램 중단 : 현재 처리 중인 프로그램 잠시 중단
  3. 문맥 교환 : 두 개의 프로그램 정보 교환
  4. 인터럽트 처리 : 새롭게 실행된 프로그램 처리
  5. 인터럽트 서비스 루틴(ISR) : 새롭게 실행된 프로그램의 부가적인 서비스 루틴 수행
  6. 프로그램 중단 부분 재실행 : 중단되었던 기존에 프로그램 실행

  ### 8-2. 문맥 교환과 인터럽트

  * 프로세스의 중단과 실행 시 인터럽트가 발생하므로, 문맥 교환이 많이 일어난다는 것은 인터럽트가 많이 발생한다는 것이다.

  ### 8-3. 문맥 교환과 시간 할당량

  * 시간 할당량이 적어지면 : 문맥 교환 수, 인터럽트 횟수, 오버헤드가 증가하지만 여러 개의 프로세스가 동시에 수행되는 느낌을 가진다.
  * 시간 할당량이 많아지면 : 문맥 교환 수, 인터럽트 횟수, 오버헤드가 감소하지만 여러 개의 프로세스가 동시에 수행되지 못하는 느낌을 가진다.

## 9. 프로세스 제어 블록(PCB : Process Control Block)

* 운영체제 내에서 한 프로세스의 존재를 정의

* 여러개의 프로세스를 수행하는 다중 프로그래밍 환경 하에서 각 프로세스를 구분하기 위한 프로세스 정보 블록이다.

  ### 9-1. PCB 항목

  * 프로세스 식별자
  * 프로세스 현재 상태 : 준비, 실행, 대기 상태를 기억시킨다.
  * 프로그램 카운터(계수기) : 다음에 실행되는 명령어의 주소를 기억시킨다.
  * 프로세스 우선순위
  * 프로세스가 적재된 기억 장치 부분을 가리키는 포인터 : 프로세스가 시작되는 기억 장치의 시작 번지를 기억시킨다.
  * 프로세스에 할당된 자원을 가리키는 포인터 : 프로세스 처리 중에 필요한 자원의 정보를 갖고 있는 기억 장소의 시작 번지를 기억한다.
  * 처리기(CPU) 레지스터 정보
  * CPU의 각종 레지스터 상태를 가리키는 포인터
  * 계정 정보
  * 기억 장치 관리 정보
  * 입출력 정보
  * 부모 프로세스를 가리키는 포인터
  * 자식 프로세스를 가리키는 포인터

## 10. CPU 스케줄링

* 최적의 효과(처리율 향상, 신속한 처리 등)을 보기 위해서는 프로세스의 계획적인 실행 순서가 필요하다.

* 계획적인 실행 순서를 CPU 스케줄링 / 프로세스 스케줄링 이라고 한다.

  ### 10-1. 스케줄러 종류

  * 상위 수준의 스케줄러 : CPU가 아닌 시스템 내의 자원들을 관리하는 수준
  * 중위 수준의 스케줄러 : 어느 프로세스부터 CPU를 사용할 수 있는지를 결정하는 CPU 스케줄러
  * 하위 수준의 스케줄러 : CPU 사용 중에 보류와 디스패치 시기를 결정하는 프로세스 스케줄러를 의미

  ### 10-2. 스케줄링 목적

  * 프로세스 스케줄링은 CPU나 자원을 효과적이며 생산성있게 사용하기 위한 소프트웨어적 계획을 의미
  * 필요한 하드웨어 레지스터를 설정함으로써 프로세스에게 CPU를 할당하고 문맥 교환을 하는 프로세스 관리 기능이다.
  * 모든 프로세스에게 공정하게 배정
  * 단위 시간당 가능한 최대한 많은 양이 처리될 수 있도록 한다.
  * 응답 시간이 신속해야 한다.
  * 같은 종류의 작업은 거의 같은 시간과 비용으로 실행될 수 있어야 한다.
  * 오버헤드를 최소화해야 한다.
  * 시스템 내의 자원이 사용하지 않는 시간이 없도록 유지해야 한다.
  * 응답 시간과 자원의 활용 간 적절한 균형이 유지되도록 해야 한다.
  * 프로세스가 무한정 기다리게 하는 것을 피해야 한다.
  * 프로세스의 상태를 파악하여 우선순위를 부여 하는 것이 좋다.
  * 중요 자원을 차지하고 있는 프로세스에게 우선권을 주어야 한다.
  * 문제로 인해 불안하지 않은 프로세스에 서비스를 많이 제공하도록 한다.
  * 부하가 많은 경우 갑자기 체증이 발생하지 않도록 조절한다.

  ### 10-3. 스케줄링 성능 평가 기준

  * CPU 이용률
  * 처리 능력(Throughput)
  * 대기 시간
  * 응답 시간
  * 반환 시간

## 11. 비선점형 프로세스 스케줄링(Non Preemptive)

* 프로세스가 CPU에 할당되면 권한을 빼앗을 수 없다.

* 일괄 처리 방식에 적당하다.

* 대화형, 시간분할, 실시간 시스템에 부적절하다.

* FIFO, SJF, HRN, 우선순위, 기한부 방식

* 문맥 교환이 적어 오버헤드가 적다.

  ### 11-1. FIFO(First Input First Out, FCFS : First Come First Served)

  * 먼저 입력된 작업을 먼저 처리한다.
  * 가장 대표적인 비선점형 방식
  * 공평하고 구현이 간단하나 평균 반환 시간이 길다.
  * 짧은 작업이나 중요한 작업을 오랫동안 기다리게 할 수 있다.

  ### 11-2. SJF(Shortest Job First, 최단 작업 우선)

  * 작업이 끝나기까지의 실행 시간 추정치가 가장 작은 작업을 먼저 실행 시킨다.
  * 크기가 큰 작업들을 어느 정도는 희생시키면서 짧은 작업들을 우선으로 처리하기 때문에 대기 리스트 안에 있는 작업의 수를 최소화 하면서 평균 반환 시간을 최소화할 수 있다.
  * 긴 작업일지라도 이미 CPU를 점유하고 있다면 뒤로 밀려나지 않고 처리되고 다음 작업들을 대상으로 재정리 한다.
  * 짧은 작업들 때문에 우선순위가 계속 밀려 나면서 긴 작업들은 무한 연기 상태가 발생할 수 있다.
  * 평균 대기 시간을 최소화 한다.
  * 무한 연기 현상을 방지하기 위해 Aging 기법을 사용하여 해결한다.
  * Aging 기법 : 자원이 할당되기를 오랜 시간 동안 기다린 프로세스는 기다린 시간에 비례하는 높은 우선순위를 부여하여 가까운 시간 안에 자원이 할당되도록 하는 기법이다.

  ### 11-3. HRN(Highest Response-ratio Next)

  * 실행 시간 추정과 선점 기능 때문에 스케줄러가 복잡해지고 남은 계산 시간들을 저장해 놓아야 하는 단점을 보안
  * 서비스 시간(실행 시간 추정치)과 대기 시간의 비율을 고려한 스케줄링
    * 대기 리스트에 있는 작업들에게 합리적으로 우선순위를 부여하여 많고, 적은 작업들의 불평등을 해소한 방식으로 SJF의 단점을 보안환 방식
    * 우선 순위 계산 공식을 이용한다.
    * 우선순위 = (대기 시간 + 서비스 시간) / 서비스 시간 (서비스 시간 = 실행(추정) 시간)

  ### 11-4. 우선순위

  * 대기 리스트에 있는 프로세스들에게 작업의 우선순위를 부여하여 CPU를 할당하는 방법
  * 중요한 작업을 먼저 할 수 있다.
  * 기아 현상, 무한 봉쇄 현상이 발생할 수 있다.

  ### 11-5. 기한부(Deadline)

  * 작업이 주어진 특별한 시간이나 만료 시간 안에 완료되도록 하는 방식이다.
  * 프로세스들이 마감 시간 내에 처리되지 않으면 폐기되거나 다시 처음부터 실행해야 한다.
  * 기한부 스케줄링에 필요한 집약적 자원 관리는 많은 오버헤드를 일으킬 수 있다.
  * 동시에 다수의 기한부 작업이 수행되면 스케줄링은 매우 어려워진다.
  * 사용자는 작업에 필요한 자원의 정보를 정확한 정보를 시스템에 제시하여야 한다.
  * 프로세스 양이 늘어나면 오버헤드 측면에서 안정적이지 못하다.

## 12. 선점형 프로세스 스케줄링(Preemptive)

## 13. 임계 구역

## 14. 상호 배제

## 15. 세마포어

## 16. 모니터

## 17. 교착상태

## 18. 인터리빙(Interleaving)

## 19. DMA(Direct Memory Access)

## 20. 주 기억 장치 다중 프로그래밍

## 21. 가상 기억 장치(보조 기억 장치) 다중 프로그래밍

## 22. 가상 기억 장치 주요 기술

## 23. 반입 전략

## 24. 배치 전략

## 25. 교체(재배치 전략)

## 26. 디스크

## 27. 디스크 스케줄링

## 28. 파일의 구조

## 29. 파일의 디스크 공간 할당

## 30. 디렉터리

## 31. 자원 보호 기법

## 32. 비밀키와 공개키

## 33. MIMD

## 34. 분산 운영체제

## 35. 투명성

## 36. 스레드

----

**모든 내용의 권리는 2018 정보처리기사(영진 닷컴 출판사) 에 있습니다.** 