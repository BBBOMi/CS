# 1 

## String, StringBuilder, StringBuffer

* String은 immutable, private final char[] 형태
* immutable인 이유 : 퍼포먼스, 동시성, GC
* StringBuilder, StringBuffer은 mutable
* StringBuffer는 Thread safe, StringBuilder는 Thread safe하지 않다. 따라서 Multi Thread 환경에서는 StringBuffer를 사용해야 한다.

## MyBatis

*  JDBC를 대체하는 Persistence framework
*  개발자가 작성한 SQL 명령어와 자바 객체를 매핑해 주는 기능을 제공
*  SQL명령을 String이 아닌 XML로 관리
*  기존 DAO 클래스에서 DB 실행을 위한 JDBC 코드를 XML로 분산한다.
*  왜 세션관리를 안해줄까? : SqlSessionFactory를 내부적으로 참조하고 있는데, 이것을 통해 자동으로 세션관리가 된다.
*  Connection Pool : DB Connection 객체를 생성하는 부분에 대한 비용과 대기시간을 줄이는 방법
*  WAS가 실행되면서 미리 일정량의 DB Connection 객체를 생성하고 pool이라는 공간에 저장한다.
*  요청에 따라 필요할 때 Pool에서 Connection 객체를 가져다 쓰고 반환한다.
*  PreparedStatement를 이용해 SQL Injection을 막는다.
*  SqlSessionFactoryBuilder : mybatis-config을 loading 하여 SqlSessionFactory 객체를 생성한다.
*  SqlSessionFactory클래스 : SqlSession 객체에 대한 팩토리 객체다. 이 객체를 통해 sqlSession 객체를 얻을 수 있다.
*  세션을 한번 생성하면 매핑구문을 실행하거나 커밋, 롤백을 하기 위해 세션을 사용할 수 있다.
*  더 이상 필요하지 않은 상태가 되면 세션을 닫는다.
*  MyBatis는 모든 쿼리를 prepared statement로 실행한다.
*  반복 실행 시 준비과정 없이 바로 실행해 좀 더 빠른 응답을 받을 수 있고, DBMS의 CPU 사용률을 줄일 수 있다.
*   DBCP(Database Connection Pool)는 Apache의 커넥션 풀 라이브러리
*  ResultMap : 반환되는 데이터의 컬럼명과 변수 명을 직접 지정해 ResultType에 지정할 때 사용

## JVM (Java Virtual Machine)

* 자바 애플리케이션을 Class Loader를 통해 읽어 들어 자바 API와 함께 실행
* java와 OS 사이에서 중개자 역할을 수행하여, java가 OS에 구애받지 않고 재사용이 가능
* 메모리 관리, Garbage Collection을 수행
* Stack 기반의 가상 머신

----

* Java Source : 사용자가 작성한 java 소스코드
* Java Compiler(Javac) : 자바 소스코드를 자바 바이트 코드로 변환
* Class Loader : Class file을 Memory(Runtime Data Area)에 적재
* Execution Engine : Byte 코드를 실행 가능하게 해석

----

* Java 프로그램 실행 과정

  1. 프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당받는다.

     JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.

  2. 자바 컴파일러(Javac)가 자바 소스코드(.java)를 읽어 들여 자바 바이트 코드(.class)로 변환시킨다.

  3. Class Loader를 통해 class 파일들을 JVM으로 Loading한다.

  4. 로딩된 class 파일들은 Execution Engine를 통해 해석된다.

  5. 해석된 바이트 코드는 Runtime Data Area에 배치되어 실질적인 수행이 이루어지게 된다.

* Class Loader

  * JVM내로 클래스(.class)를 로드하고, Linking를 통해 배치되는 작업을 수행하는 모듈
  * Runtime시에 동적으로 클래스를 로드한다.

* Runtime Data Area : 프로그램을 수행하기 위해 OS에서 할당받은 메모리 공간

  1. PC Register : Thread가 시작될 떄 생성, Thread가 어떤 부분을 어떤 명령으로 실행해야 할지에 대한 기록을 하는 부분, 현재 수행 중인 JVM 명령의 주소를 가진다.
  2. JVM 스택 영역
     * 프로그램 실행 과정에서 임시로 할당되었다가 메소드를 빠져 나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역
     * 지역 변수, 임시 데이터, 스레드나 메소드의 정보를 저장한다.
     * 메소드 호출 시 마다 각각의 스택 프레임(해당 메소드 만을 위한 공간)이 생성된다.
     * 메소드 수행이 끝나면 프레임 별로 삭제를 한다.
     * Local Variable, 매개변수, 지역변수, 리턴 값 및 연산 시 일어나는 값들을 임시로 저장한다.
  3. Native Method Stack
     * 자바 프로그램이 컴파일되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역
     * JAVA가 아닌 다른 언어로 작성된 코드를 위한 공간
     * Java Native Interface를 통해 바이트 코드로 전환하여 저장하게 된다.
     * 커널이 스택을 잡아 독자적으로 프로그램을 실행시키는 영역이다.
  4. Method Area(Calss Area, Static Area)
     * 클래스 정보를 처음 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간이다.
     * 멤버 변수의 이름, 데이터 타입, 접근 제어자의 정보
     * 메소드의 이름, 리턴 타입, 매개변수, 접근 제어자의 정보
     * Class 인지 Interface인지의 여부 저장, Type의 속성, 전체 이름, Super Class의 전체 이름
     * Method Area는 클래스 데이터를 위한 공간
     * GC의 관리 대상에 포함된다.
  5. Heap Area
     * 객체를 저장하는 가상 메모리 공간
     * new 연산자로 생성된 객체와 배열을 저장한다.
     * class area영역에 올라온 클래스들만 객체로 생성할 수 있다.
       * Permanent Generation
         * 생성된 객체들의 주소값이 저장된 공간
       * New/Young Generation
       * Old Generation

## 스프링 컨테이너

* 컨테이너는 보통 인스턴스의 생명 주기를 관리
* 생성된 인스턴스들에게 추가적인 기능을 제공하도록 한다.
* 코드의 처리과정을 위임받은 독립적인 존재
* 컨테이너는 적절한 설정만 되어있다면 누구의 도움 없이도, 코드를 스스로 참조한 뒤 알아서 객체의 생성과 소멸을 컨트롤해준다.
* 스프링 컨테이너는 스프링 프레임워크의 핵심부에 위치한다.
* 종속 객체 주입을 이용하여 애플리케이셔을 구성하는 컴포넌트들을 관리한다.
* 객체를 관리하는 컨테이너를 제공한다.
* 스프링은 컨테이너에 객체를 담아 필요할 때 객체를 가져와 사용할 수 있도록 하며, BeanFactory, ApplicationContext가 있다.
* ApplicationContext는 BeanFactory(interface)를 구현한 것이다.
* BeanFactory 인터페이스는 빈 객체를 관리하고 빈 객체간의 의존 관계를 설정하는 가장 단순한 컨테이너다.
* ApplicationContext 인터페이스는 BeanFactory 인터페이스를 상속 받은 하위 인터페이스, 빈 관리 기능 이외도 객체의 생명주기, 파일과 같은 자원처리 추상화등 추가적인 기능 제공

## IOC(Inversion of Control)

* 프로그램의 제어 흐름 구조가 바뀌는 것이다.
* 제어권이 컨테이너로 넘어가게 되는 것이 IOC
* 제어권이 컨네이너로 넘어옴으로써 DI, AOP가 가능하다.
* 인스턴스의 생성부터 소멸까지의 객체 생명주기를 스프링 컨테이너가 관리한다.
* 스프링에서 객체가 만들어지는 순서
  1. 객체 생성
  2. 의존성 객체 주입(스스로 만드는 것이 아니라 제어권을 가진 스프링에게 위임하여 스프링이 많들어 놓은 객체를 주입한다.)
  3. 의존성 객체 메소드 호출

## DI (Dependency Injection)

* 인스턴스를 자신이 아닌 외부(IOC 컨테이너)에서 생성후 주입한다.
* 기능이 변경될 때 마다 코드를 변경하는 것은 비용이 많이 들게 되므로 가급적 코드의 변화가 적어지도록 프로그램을 작성하기 위해 탄생
* 모듈 간의 결합도를 낮춰서 유연한 변경을 가능하도록 한다.
* 불필요한 의존 관계를 없애거나 줄일 수 있다.
* 각 객체를 bean 컨테이너으로 관리한다.
* IOC를 구현하는 한 가지 방법이 DI이다.

## AOP (Aspect Oriented Programming)

* 관점 지향 프로그래밍
* 로직 주입
* 다수의 모듈에 공통적으로 나타나는 부분을 관리
* 프록시 패턴

## @Autowired

* 의존 객체를 자동으로 삽입해 주는 어노테이션
* 해당 타입의 빈 객체가 존재하지 않거나, 2개 이상 존재할 경우 예외 발생
* bead 객체를 검색한 후 어노테이션이 적용된 프로퍼티, 메소드, 생성자 등에 객체를 주입해 줄때 타입을 이용하게 된다.

## @Service

## @Repository

## @Bean

* 스프링 IOC 컨테이너에 의해서 자바 객체가 만들어 지게 되면 이 객체를 스프링 빈이라고 한다.
* 기본적으로 스프링의 ApplicationContext 구현은 초기화 프로세스에서 모든 싱글톤 빈을 생성 및 설정하게 된다.
* 따라서 문제가 있을 경우 해당 빈을 사용할 때가 아닌 초기화 단계에서 바로 알 수 있다.
* 스프링 IOC 컨테이너에 의해서 인스턴스화 되어 조립되거나 관리되는 객체

## 웹 애플리케이션 동작 원리

1. 웹 애플리케이션이 실행되면 Tomcat(WAS)에 의해 web.xml이 loading된다.

2. web.xml에 등록되어 있는 ContextLoaderListener(Java Class)가 생성된다.

   ContextLoaderListener 클래스는 ServletContextListener 인터페이스를 구현하고 있으며, ApplicationContext를 생성하는 역할을 수행한다.

3. 생성된 ContextLoaderListener는 root-context.xml을 loading 한다.

4. root-context.xml에 등록되어 있는 Spring Container가 구동된다. 이 때 작성된 비즈니스 로직에 대한 부분과 DAO, VO 객체들이 생성된다.

5. 클라이언트로부터 웹 애플리케이션으로 요청이 온다.

6. DispatcherServlet이 생성된다.

   DispatcherServlet은 FrontController의 역할을 수행한다.

   클라이언트로부터 요청 온 메시지를 분석하여 알맞은 Controller에게 전달하고 응답을 받아 요청에 따른 응답을 어떻게 할 지 결정한다.

   실질적인 작업은 Controller에서 이루어진다.

   이러한 클래스들을 HandlerMapping, ViewResolver 클래스라고 한다.

7. DispatcherServlet은 servlet-context.xml을 loading 한다.

8. 두번째 Spring Container가 구됭되며 응답에 맞는 Controller들이 동작한다.

   이 때 첫번째 Spring Container가 구동되면서 생성된 DAO, VO, ServiceImpl 클래스들과 같이 알맞은 작업을 처리한다.

## OOP (Object Oriented Programming, 객체 지향 프로그래밍)

  - 캡슐화, 다형성, 상속을 이용하여 코드의 재사용성을 증가시키고, 유지보수를 감소시키는 장점을 얻기 위해서 객체들을 연결 시켜 프로그래밍 하는 것

## DDD (Domain Driven Design, 도메인 주도 설계)

## TDD (Test Driven Development, 테스트 주도 개발)

* 언제 테스트를 작성하고 수행해야 하는지에 대한 절차

1. 테스트 코드 작성
2. 작성한 테스트 코드와 기존에 작성된 다른 테스트를 수행한다. 이 시점에서 새로 추가된 테스트 코드는 실패할 것이다. 만약 실패하지 않는 다면 올바른 것을 테스트하고 있지 않은 것이므로 버그가 있다는 것이다.
3. 실패한 테스트를 성공시키기 위한 최소한의 코드를 구현
4. 실패한 테스트가 성공하는지 확인하기 위해 테스트를 재수행
5. 필요에 따라 작성한 코드를 리팩토링
6. 1번부터 다시 반복

## ArrayList

  * 상당히 빠르고 크기를 마음대로 조절 할 수 있는 배열
  * 단방향 포인터 구조로 자료에 대한 순차적인 접근에 강점(각 인덱스를 가지고 있기 때문에)
  * 내부적으로 데이터를 배열에서 관리하며 데이터의 추가, 삭제를 위해 임시 배열을 생성해 데이터를 복하는 방법, 따라서 대량, 빈번하게 데이터를 추가 삭제 하는 경우 성능 저하를 일으킬 수 있다.
  * 검색 : O(1)
  * 삽입/삭제 : O(N)

## LinkedList

  * 양방향 포인터 구조, 삭제가 빈번할 경우 빠른 성능을 보장
  * 스택, 큐, 양방향 큐 등을 만들기 위한 용도로 쓰임
  * 데이터의 추가, 삭제시 불필요한 데이터의 복사가 없어 데이터의 추가, 삭제시에 유리한 반면, 데이터의 검색시에는 처음부터 노드를 순회해야 하기 때문에 성능상 불리하다.
  * 검색 : O(N)
  * 삽입/삭제 : O(1)

## Deque

* 양쪽 끝에서 삽입과 삭제가 모두 가능
* 두 개의 포인터를 사용하여 양쪽에서 삭제, 삽입을 발생 시킨다.
* 큐 + 스택

## Index

* 읽기 성능을 향상시키기 위한 일종의 자료 구조
* Full table scan은 가장 느린 scanning 방법
* 해당 테이블의 컬럼을 색인화하여 검색시 해당 테이블의 레코드를 full scan하는것이 아니라 색인화 되어있는 Index 파일을 검색하여 검색속도 향상
* B+ 트리로 저장된다.
* index로 설정한 컬럼값이 변경되거나 추가되면, index도 업데이트 된다. 따라서 적절하게 index를 설정해야 한다.
* 데이터의 삭제, 삽입이 빈번한 경우 index의 성능이 떨어진다. 매번 b+트리를 수정해야 하기 때문이다.
* primary key는 db가 자동으로 index 기능을 설정하여 관리한다.

## Join

* 두 개 이상의 테이블을 하나의 집합으로 만드는 연산
* NL join은 중첩된 for문 방식으로 작동됨

## 다형성(Polymorphism)

* 상속을 통해 기능을 확장하거나 변경하는 것을 가능하게 해 준다.
* 같은 클래스 내에 코드의 길이를 줄여주는 것까지 도와준다.
* 하나의 메소드나 클래스가 있을 때 이것들이 다양한 방법으로 동작하는 것을 의미한다.
* ex) List
* 다형성의 조건
  * 공통의 부모 : 클래스 계층 구조(상속 관계) (List)
  * 공통의 메소드 재정의 : 메소드 재정의, 동적 바인딩 (add)
  * 부모 타입의 변수로 호출 : 업 캐스팅 후 재정의된 메소드 호출 List list = new ArrayList();

## Interface

* 추상 클래스보다 추상화 정도가 훨씬 높다.
* 추상 메소드들로만 이루어져 있다.
* 메소드의 선언만 가능하다.
* 메소드는 표준화된 공통 기능을 가진다.
* implements 키워드를 사용해 구현한다.
* 서로 다른 클래스(외부)를 연결시켜주는 장치
* 공통 작업시 충돌을 방지하기 위해서, 유지 보수의 용이를 위해 인터페이스를 사용한다.

## 추상 클래스

* 추상화는 클래스 간의 공통점을 찾아내서 공통의 조상을 만드는 작업
* 반드시 하나 이상의 추상 메소드를 가지며, 객체를 생성할 수 없다.
* 슈퍼 클래스로 사용할 수는 있으며, 추상 메소드를 사용하기 위해서는 반드시 해당 메소드를 재정의 해야만 한다.
* abstract 키워드를 사용한다.
* 자손 클래스에서 추상 메소드를 반드시 구현하도록 강요하기 위해 사용한다.

## Garbage Collection

* new 연산자를 사용하여 생성된 객체가 자동으로 제거되는 것을 Garbage Collection이라고 한다. (heap segment)
* 어떤 객체를 참조하는 변수가 하나라도 있다면, 그 객체는 사용되고 있는 것이고, 어떤 객체를 참조하는 변수가 하나라도 없다면 그 객체는 GC 된다.
* GC는 JVM에 의해서 자동으로 실행된다.
* GC가 실행될 때, 그 JVM에서 애플리케이션 thread는 모두 정지되고, 오직 GC thread만 실행된다.
* System.gc()는 GC 작업을 즉시 실행하도록 하는 메소드이다. GC는 JVM이 스스로 실행하도록 나 두는 것이 좋다.
* 변수에 NULL을 대입하는 것으로 그 객체는 GC의 대상이 된다.
* 지역 변수가 참조하는 객체들은 금방 GC 되지만, 멤버 변수가 참조한 객체들은 오랫동안 살아남는다.
* 오래된 객체의 멤버 변수가 젊은 객체를 참조하는 경우는 드물다.

## JIT Compile (Just In Time Compilation)

* 자바는 jit 컴파일 방식을 사용한다.
* 바이트 코드를 실행하기 직전에 기계어 코드로 컴파일 하는 방식
* 바이트 코드를 해석해서 실행하는 것 보다(인터프리터) 기계어 코드로 변환해서 실행하는 쪽이 훨씬 더 빠르다.
* 실행할 때 마다 매번 다시 jit 컴파일을 해야 한다.
* dynamic optimization(동적 최적화)이 가능하다.
* 소스코드와 동일한 순서로 기계어 코드를 생성하지 않고, 좀더 빠르고 효율적으로 실행될 수 있도록 실행순서를 재배치하고 조정하여 기계어 코드를 생성한다.
* 실행하는 시점에 실행 순서를 재배치하고 조정하여 기계어 코드를 생성한다.

## stack overflow 공격

* 함수가 리턴할 때 되돌아갈 기계어 코드이 주소가 stack segment에 저장되고, 지역 변수도 stack segment에 저장된다는 점을 노린 공격이다.
* 데이터가 저장될 때 배열의 뒤 까지 데이터가 넘치도록 한다.(overflow)
* 이렇게 넘쳐서 저장된 데이터가 함수가 리턴 주소가 저장된 곳 까지 덮어쓰도록 한다.
* 함수가 리턴할 때, overflow 되어 변경된 주소로 리턴하게 된다.
* 공격자가 원하는 곳으로 리턴하게 되어, 다른 기계어 코드가 실행되게 된다.
* java는 JVM이 이것을 검사하기 때문에 overflow가 가능하지 않다. 대신 오류가 발생한다.(IndexOutOfBoundsException)

## C & java

* C는 절차지향, Java는 객체지향
* C는 하드웨어를 직접 제어할 수 있다.
* java는 설계적인 측면이 강조된 방식

## static

* 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통적으로 사용해야 하는 것에 static를 붙인다.

* 인스턴스를 생성하지 않아도 사용할 수 있다.
* static이 붙은 메소드/함수는 인스턴스 변수를 사용할 수 없다.
* static은 JVM의 메소드 영역에 존재하고, JVM이 실행될 때 생성된다.
* static은 클래스가 사용되기 전에 미리 메모리에 올라간다.
* 생성할 때 마다 인스턴스가 메모리에 올라가는 것이 아니라, 고정 메모리이므로 효율적이다.
* 인스턴스를 생성하지 않고 바로 사용하기 때문에 참조속도가 빠르다.
* 메모리 낭비의 가능성이 있다.
* static 사용의 예로 싱글톤(singleton)
* GC의 대상이 되지 않는다.
* 자주 변경되지 않는 부분이나, 설정 파일 정보인 경우 사용

## Hash Table

* 데이터가 저장될 자리가 데이터 해시 값에 의해 결정되는 자료구조
* 해시 테이블의 성능은 공간을 팔아 얻어낸 것이다.
* 저장할 데이터의 값으로 저장할 위치를 계산할 수 있다.
* 평균 상수 시간에 삽입, 삭제, 검색이 가능하다.
* 매우 빠르게 자료를 저장/검색 해야 하는 경우에 유용하다.

## JPA (Java Persistent API)

* ORM 표준 기술로 Higernate, OpenJPA, EclipseLink, TopLink Essentials 같은 구현체가 있고 이에 대한 표준 인터페이스가 JPA다.
* 객체지향적으로 데이터를 관리할 수 있기에 비즈니스 로직에 집중할 수 있어 객체 지향 개발이 가능하다.

## Paging(고정 분할, 정적 분할)

* 

## CPU 스케줄링

* 최적의 효과(처리율 향상, 신속한 처리)을 보기 위해 (프로세스의) 계획적인 실행 순서가 필요하다. 계획적인 실행 순서가 스케줄링이다.
* 모든 프로세스에게 공정하게 배정하고, 단위 시간당 가능한 많은 양이 처리될 수 있도록 해야 한다.
* 응답 시간이 최소회해야 하고, 오버헤드를 최소화해야 한다.
* 비선점형 스케줄링 : 프로세스가 cpu에 할당되면 권한을 빼앗을 수 없다.
* 선점형 스케줄링 : 프로세스가 cpu에 할당되어도, 우선도가 높은 작업이 들어오면 권한을 빼앗긴다.

## OSI 7계층

* 프로토콜을 기능별로 나눈 것이다.
* 각 계층은 하위 계층의 기능만을 이용하고, 상위 계층에게 기능을 제공한다.

### 1계층 : Physical layer (물리 계층)

* 네트워크 하드웨어 전송 기술을 이룬다.

### 2계층 : Data Link layer (데이터 링크 계층)

* point to point 간 신뢰성있는 전송을 보장하기 위한 계층

### 3계층 : Network layer (네트워크 계층)

* 여러개의 노드를 거칠때마다 경로를 찾아주는 역할을 하는 계층

### 4계층 : Transport layer (전송 계층) 

* End to end 의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 해 주어, 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다.

### 5계층 : Session layer (세션 계층)

### 6계층 : Presentation (표현 계층)

### 7계층 : Application layer (응용 계층)

## Spring

* IOC와 AOP를 지원하는 경향의 컨테이너 프레임워크

## 정렬 알고리즘

## Replication (레플리케이션)

* 복제, 저장소를 물리적으로 분리하여 데이터를 유지, 데이터를 이중화
* 기본적으로 Master-slave 구조
* write은 Master, read는 slave
* 쓰기 부하 분산은 불가능하지만, 일기 부하 분산은 가능
* 로그 기반으로 비동기적으로 데이터를 복제한다.
* 방식

1. Master에서 데이터 변경이 일어나면 자신의 데이터베이스에 반영
2. Master에서 변경된 이력을 Binary Log에 기록 후 관련 이벤트를 발생
3. Slave IO_THREAD에서 Master 이벤트를 감지하고, Master Binary Log를 자신의 Relay Log에 기록
4. Slave SQL_THREAD 는 Relay Log를 일고, 자신의 데이터베이스에 기록

* Master에서는 여러 세션에서 데이터 변경 처리가 가능하지만, Slave에서는 오직 하나의 SQL_THREAD에서만 데이터 변경 처리가 가능하다.

## 팩토리 패턴

* 객체를 만들어 내는 공장(Factory)을 만드는 패턴
* 객체를 만들어내는 부분을 서브 클래스에 위임하는 패턴

## 옵저버 패턴

## 템플릿 패턴

* 상위 클래스에서 전체적인 구조를 결정하고, 하위 클래스에서 그 구체적인 내용을 결정하는 패턴
* 안드로이드의 onCreate()
* 추상 메소드의 실제 구현

## HTTP 동작 순서

1. 웹 브라우저에 사용자가 URL 주소 입력
2. DNS 서버에 웹 서버의 호스트 이름을 주고 IP 주소를 얻어온다.
3. 웹 서버와 TCP 연결 시도 (3 way handshake)
4. 서버에게 명령 전송(get, post, put, delete...)
5. 서버가 클라이언트에게 데이터를 회신
6. 서버와 클라이언트같 연결 해제 (4 way handshake)
7. 웹 브라우저가 웹 문서를 출력

## 3 Way Handshake

* TCP 통신을 하기 위한 연결 방식
* 최초에 Server에서 열려있는 포트는 LISTEN, Client에서는 CLOSED

1. Client에서 Server에 연결 요청을 하기위해 SYN 데이터를 보낸다.

2. Server에서는 해당 포트는 LISTEN 상태에서 SYN 데이터를 받고, SYN_RCV로 상태가 변경된다.

   그리고 Client에게 요청을 정상적으로 받았다는 대답(ACK)과 Client에게 포트를 열어달르는 SYN을 보낸다.

3. Client에서는 SYN + ACK를 받고 ESTABLISHED로 상태를 변경하고 서버에 요청을 잘 받았다는 ACK를 전송한다.

4. ACK를 받은 서버는 상태가 ESTABLISHED로 변경된다.

## 4 Way Handshake

* TCP 통신을 종료하기 위한 방식
* 정상적인 종료 상황
* 최초에 서로 통신 상태이기 때문에 Server, Client 모두 ESTABLISHED 상태

1. 통신을 종료하고자 하는 Client가 Server에게 FIN을 보내고, 자신은 FIN_WAIT_1 상태로 대기한다.

2. FIN을 받은 서버는 해당 포트를 CLOSE_WAIT로 바꾸고 잘 받았다는 ACK을 Client에게 보내고,  그와 동시에 Server에서는 해당 포트에 연결되어있는 애플리케이션에게 Close()를 요청한다.

3. ACK를 받은 Client는 FIN_WAIT_2 상태로 변경한다.

4. Close() 요청을 받은 애플리케이션은 종료 프로세스를 진행시켜 최종적으로 close()가 되고 Server는 FIN을 Client에게 전송후 자신은 LAST_ACK로 상태가 변경된다.

5. FIN_WAIT_2에서 Server가 연결을 종료했다는 신호를 기다리다가 FIN을 받으면 잘 받았다고 ACK를 Server에게 전송하고 Client은 TIME_WAIT로 상태를 바꾼다.

   TIME_WAIT 상태는 일정 시간이 지나면 CLOSED로 변경된다.

   최종 ACK를 받은 서버는 자신의 포트도 CLOSED로 닫게 된다.

* 비 정상적인 종료 상황

* CLOSE_WAIT 상태 : 애플리케이션에서 Close()를 처리하지 못하면 서버 포트는 CLOSE_WAIT 상태로 계속 대기하게 된다. CLOSE_WAIT 상캐가 statement에 많아지게 되면, Hang이 걸려 더이상 연결을 하지 못하게 된다.

* FIN_WAIT_1 상태 : Server에 종료 요청을 했는데, ACK를 받지 못한 상태로 기다리고 있다. 서버를 찾을 수 없거나, 네트워크 방화벽의 문제일 수 있디. FIN_WAIT_1 상태는 일정 시간이 지나 TIME OUT이 되면 자동으로 닫힌다.

* FIN_WAIT_2 상태 : Client가 Server에 종료를 요청한 후 Server에서 요청을 접수했다고 ACK를 받았지만, Server에서 종료를 완료했다는 FIN 상태를 받지 못하고 기다리는 상태이다. 

  양방의 두번의 통신이 이미 이루어졌기 때문에 네트워크의 문제는 아니라고 판단한다.

  Server에서 CLOSE를 처리하지 못하는 경우일 수도 있다.

  FIN_WAIT_2는 일정 시간이 지나 TIME_OUT이 되면 스스로 CLOSE하게 된다.

* TIME OUT이 길어서 많은 수의 소켓이 늘어만 난다면 메모리 부족의 현상이 발생할 수 있다.

## Generic

* 다양한 타입의 객체들을 다루는 메소드나 컬렉션 클래스에 컴파일 시에 타입 체크를 해 주는 기능이다.
* 클래스 내부에서 사용할 데이터의 타입을 나중에 인스턴스를 생성할 때 확정한다.
* 객체의 타입을 컴파일 시에 체크하기 때문에 객체 타입의 안전성을 높이고, 형 변환의 번거로움이 줄어든다.
* 타입 안정성을 제공한다. 의도하지 않은 타입의 객체를 저장하는 것을 막고, 저장된 객체를 꺼내올 때 원래의 타입과 다른 타입으로 형 변환되어 발생할 수 있는 오류를 줄여준다.
* 타입체크와 형 변환을 생략할 수 있으므로 코드가 간결해진다. 사용할 객체 타입을 미리 명시해줌으로써 형 변환을 하지 않아도 된다.
* 다형성을 사용하는 경우에 부모 타입을 지정함으로써 여러 종류의 객체를 저장할 수 있다.
* 복수의 제너릭을 사용할 시엔 , 를 사용한다. <T, S>
* 참조 데이터 타입에 대해서만 사용할 수 있다.

## 상태코드

* 200 : 성공
* 201 :  작성됨
* 400 : 
* 500 : 서버 내부 에러

## 자바 8

## Rest

## API

## ORM

## Transcation (트랜잭션)

* 데이터베이스 관리 시스템 또는 유사한 시스템에서 상호작용의 단위이다.
* 유사한 시스템이란 트랜잭션이 성공과 실패가 분명하고 상호 독립적이며 일관되고 믿을 수 있는 시스템을 의미한다.
* ACID는 데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질을 가리키는 약어
* Atomicity 원자성 : 중간 단계까지 실행되고 실패하는 일이 없도록 하는 것이다.
* Consistency 일관성 : 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다. 
* Isolation 고립성 : 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다. 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미한다.
* Durability 지속성 : 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다. 시스템 문제, DB 일관성 체크 등을 하더라도 유지되어야 함을 의미힌다. 전형적으로 모든 트랜잭션은 로그로 남고 시스템 장애 발생 전 상태로 되돌릴 수 있다. 트랜잭션은 로그에 모든 것이 저장된 후에만 commit 상태로 간주될 수 있다.

