# Server

## 1. JSP(Java Server Page)

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/7/72/JSP_Model_2.svg/220px-JSP_Model_2.svg.png)

* 웹 환경에서 작동하는 웹 애플리케이션
* Java를 이용한 **Server Side Script** 언어
* HTML내에 Java 코드를 삽입하여 웹 서버에서 동적으로 웹 페이지를 생성하여 웹 브라우저에게 돌려주는 언어이다.
* <% ... %> 스크립트 영역이 있다.
* 실행시 javax.servlet.http.HttpServlet 클래스를 상속받은 자바 소스코드로 변환된 다음 컴파일되어 실행된다.
* Servlet Container : JSP 파일을 Servlet 클래스로 변환하고 실행시켜 준다. (Ex **Tomcat**)
* 하나의 JSP 페이지가 하나의 자바 클래스이기 때문에 모든 자바 라이브러리를 끌어다 쓸 수 있다.
* Servlet Container도 Java 프로그램이며, JVM 위에서 실행된다.

  ### 동작 구조

  1. 클라이언트에서 서비스가 요청되면
  2. JSP의 실행을 요구 하고
  3. JSP는 웹 애플리케이션 서버의 서블릿 컨테이너에서 서블릿 원시코드로 변환 된다.
  4. 서블릿 원시코드는 바로 컴파일된 후 실행되어 결과를 HTML 형태로 클라이언트에 돌려 준다.

## 2. Java Servlet

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/4/40/JSPLife.png/400px-JSPLife.png)

* Java를 사용하여 웹 페이지를 동적으로 생성하는 서버측 프로그램, 혹은 그 사양을 말한다. =  **Servlet(서블릿)**
* 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.
* JSP와 비슷한 점이 있지만, JSP가 HTML에 Java 코드를 포함하고 있는 반면, 서블릿은 Java코드를 HTML 코드를 포함하고 있다.
* 웹 시스템이 구현되고 있다.
* 비슷한 서비스 : PHP, ASP
* 외부 요청마다 프로세스보다 가벼운 스레드로써 응답하기때문에 CGI 보다 가볍다.
* Java로 구현되기 때문에 다양한 플랫폼에서 동작한다.

## 3. Web Container(Servlet Container)

* 웹 서버의 컴포넌트 중 하나로 Java Servlet과 상호작용한다.
* 웹 컨테이너는 Servlet의 생명주기를 관리하고, URL과 특정 Servlet을 맵핑하여 URL 요청이 올바른 접근 권한을 갖도록 보장한다.
* 웹 컨테이너는 서블릿, JSP 파일, 서버 사이드 코드가 포함된 다른 타입의 파일들에 대한 요청을 다룬다.
* 웹 컨테이너는 서블릿 객체를 생성하고, 서블릿을 로드와 언로드하며, 요청과 응답 객체를 생성하고 관리하고 다른 서블릿 관리 작업을 수행한다.
* 웹 컨포넌트 자바 EE 아키텍처 제약을 구현하고, 보안, 병행성, 생명주기 관리, 트랜잭션, 배포 등 다른 서비스를 포함하는 웹 컴포넌트의 실행 환경을 명세한다.
* 아파치 톰캣은 아피치 소프트웨어 라이센스 하에 사용할 수 있는 오픈 소스 웹 컨테이너다.

## 4. Web Server

1. 웹 서버 : 웹 브라우저와 같은 클라이언트로부터 HTTP 요청을 받아들이고, HTML 문서와 같은 웹 페이지를 반환하는 프로그램
2. 웹 서버(하드웨어) : 위의 프로그램을 실행하는 PC

* 웹 서버는 HTTP를 통해 웹 브라우저에서 요청하는 HTML 문서나 CSS, 이미지 파일 등 정적 컨텐츠를 전송해주는 서비스 프로그램

* 컨텐츠를 제공하는 것이 주된 기능이지만, 클라이언트로부터 컨텐츠를 전달 받는 것도 기능에 속한다.

* 파일 업로드를 포함하여 클라이언트에서 제출한 웹 폼을 수신하기 위해 사용된다.

* 서버 사이드 스크립트 언어를 지원한다.

* 서버 소프트웨어의 변경 없이도 웹 서버가 수행할 동작을 분리된 서버 사이드 스크립트 언어에 기술할 수 있다.

* 서버 사이드 스크립트 언어를 통해 구현되는 기능이란 HTML 문서를 동적으로 생성하는 것을 말한다.

* 동적으로 생성된 HTML 문서는 동적 컨텐트라 하는데 주로 데이터베이스의 정보를 조회해서 보여주거나 수정하기 위해 사용된다. 

* 동적 컨텐트와 대비되는 개념으로 정적 컨텐트가 있는데 일반적으로 동적 컨텐트보다 더 빠르게 동작하고 쉽게 캐시될 수 있지만, 반환되는 컨텐트의 내용이 항상 동일하다.

* Apache HTTP, Nginx, IIS

  ### 공통 기능

  * HTTP
  * 통신 기록
  * 인증
  * 정적 컨텐츠 관리
  * HTTPS 지원
  * 컨텐츠 압축
  * 가상 호스팅
  * 대용량 파일 지원
  * 대역폭 스로틀링

## 5. Web Application Server(WSA)

* 인터넷 상에서 HTTP를 통해 사용자 컴퓨터나 장치에 애플리케이션을 수행해 주는 미들웨어이다.

* WAS는 동적 서버 컨텐츠를 수행하는 것으로 일반적인 웹 서버와 구별이 되며, 주로 DB 서버와 같이 수행이 된다.

* 대부분 자바 기반

* 일반적으로 Web Server의 기능을 내제하고 있어 Web Server가 없어도 서비스가 가능하다.

* Tomcat

  ### 기본 기능

  1. 프로그램 실행 환경과 데이터베이스 접속 기능을 제공한다.
  2. 여러 개의 트랜잭션을 관리한다.
  3. 업무를 처리하는 비즈니스 로직을 수행한다.

* WSA의 내부 구조

![wasì ë´ë¶ëì](http://myblog.opendocs.co.kr/wp-content/uploads/2014/09/was%EC%9D%98-%EB%82%B4%EB%B6%80%EB%8F%99%EC%9E%91-1024x497.png)

1. Web Server로 부터 요청이 들어오면 제일 먼저 컨테이너가 이를 알맞게 처리한다.
2. 컨테이너는 web.xml(배포 서술자)를 참조하여 해당 서블릿에 대한 스레드를 생성하고 httpservletRequest 및 httpServletResponse 객체를 생성하여 전달한다.
3. 다음으로 컨테이너는 서블릿을 호출(service())한다.
4. 호출된 서블릿의 작업을 담당하게 된 스레드(미리 생성된 스레드)는 요청에 따라 doPost(), 또는 doGet()을 호출한다.
5. 호출된 doPost(), doGet() 메소드는 생성된 동적 페이지를 Response 객체에 실어서 컨테이너에 전달한다.
6. 컨테이너는 전달받은 Response 객체를 HTTPResponse 형태로 전환하여 웹 서버에 전달하고 생성되었던 스레드를 종료하고, httpservletRequest 및 httpServletResponse 객체를 소멸시킨다.

* 출저 : http://myblog.opendocs.co.kr/archives/tag/ws-was-%EC%B0%A8%EC%9D%B4

## 6. Apach Tomcat

* 아파치 소프트웨어 재단에서 개발한 서블릿 컨테이너/웹 컨테이너만 있는 WAS

* 웹 서버와 연동하여 실행할 수 있는 자바 환경을 제공하여 JSP와 자바 서블릿이 실행할 수 있는 환경을 제공한다.

* 관리툴을 통해 설정을 변경할 수 있지만, XML 파일을 편집하여 설정할 수도 잇다.

* HTTP 서버도 자체 내장하기도 한다.

* 오픈소스 소프웨어

* 서블릿이나 JSP를 실행하기 위한 서블릿 컨테이너를 제공하며, 상용 WAS에서도 서블릿 컨테이너로 사용하는 경우가 많다.

* 아파치 웹 서버와 연동모듈을 사용하여 연동하여 안정적인 시스템을 구축한다.

  ### 단점

  * 톰캣은 웹 서버로 사용되기보다는 WAS로 사용된다.
  * 톰캣은 html 같은 정적 페이지를 로딩하는데 웹 서버보다 수행 속도가 느리다. 
  * 이를 해결하기 위해서 아파치와 연동한다. 아파치는 html 같은 정적인 페이지를 로드하는 데에 사용되는 웹 서버이다.

  ### 원리

  * 아파치가 실행되면 아파치는 html 파일은 자신이 수행하고 jsp 파일은 톰캣으로 넘겨서 톰캣이 수행하게 만든다. 
  * 톰캣 특성상 java 언어만 해석이 가능하기 때문에 톰캣에 자체 내장되어 있는 http 서버를 사용하더라도 php 언어로 작성된 서버 페이지는 실행이 불가능하다. 
  * 따라서 php와 jsp 모두를 사용하고 싶다면 아파치에서 php를 호출하고 톰캣에서 jsp를 호출 하도록 구성하여 상호 보완적 동작을 수행하도록 구성할 수도 있다.

## 7. Apache HTTP 서버

* 아파치 소프트웨어 재단에서 관리하는 HTTP 웹 서버이다.
* 톰캣 등의 웹 애플리케이션 서버와 같이 사용할 수 있다.
* Open SSL을 설치하여 보안을 강화할 수 있다.(http -> https)

## 8. Nginx

* Web Server 소프트웨어로 가벼운 성능을 목표로 한다.

* 웹 서버, 리버스 프록시 및 메일 프록시 기능을 가진다.

* 엔진 엑스는 요청에 응답하기 위해 비동기 이벤트 기반 구조를 가진다. 이러한 구조는 서버에 많은 부하가 생길 경우 성능을 예측하기 쉽게 해준다.

* 아피치 HTTP 서버의 스레드/프로세스 기반 구조를 가지는 것과 대조적이다.

  ### HTTP 프록시와 웹 서버 기능

  * 정적 파일과 인덱스 파일 표현, 자동 인덱싱 기능.
  * 캐싱을 통한 리버스 프록시
  * 로드 밸런싱
  * 고장 진단
  * SSL 지원
  * 캐싱을 통한 FastCGI 지원
  * Name-, IP-기반 가상서버
  * FLV 스트리밍
  * MP4 스트리밍 모듈을 이용한 MP4 스트리밍
  * 웹페이지 접근 인증
  * gzip 압축
  * 10000개의 동시 접속을 처리할 수 있는 능력
  * URL 다시쓰기 (URL rewriting)
  * 맞춤 로깅
  * 서버 사이드 기능 포함
  * WebDAV

  ### 메일 프록시 기능

  * SMTP, POP3, IMAP 프록시
  * STARTTLS 지원
  * SSL 지원

## 9. HTTP(HyperText Transfer Protocol)

* WWW 상에서 정보를 주고 받을수 있는 프로토콜
* HTML 문서를 주고 받는 데에 쓰인다.
* TCP, UDP를 사용하며 80번 포트를 사용한다.
* 클라이언트와 서버 사이에 이루어지는 req/res 프로토콜이다.
* HTTPS(HTTP over Secure Socket Layer)는 보안이 강화된 버전이다.

### HTTP 상태 코드

| 코드 |      오류      |                         설명                          |
| :--: | :------------: | :---------------------------------------------------: |
| 200  |      성공      |          서버가 요청을 성공적으로 처래했다.           |
| 201  |     작성됨     | 성공적으로 요청되었스며, 서버가 새 리소스를 작성했다. |
| 202  |     허용됨     |    서버가 요청을 접수했지만, 아직 처리하지 않았다.    |
| 301  |   영구 이동    |          요청한 페이지를 새 위치로 이동했다.          |
| 400  |  잘못된 요청   |         서버가 요청의 구문을 인식하지 못했다.         |
| 401  |  Unauthorized  |         이 요청은 인증이 필요하다.(인증 실패)         |
| 403  |   Forbidden    |        서버가 요청을 거부하고 있다.(인가 실패)        |
| 404  |   Not Found    |         서버가 요청한 페이지를 찾을 수 없다.          |
| 500  | 서버 내부 오류 |     서버에 오류가 발생하여 요청을 수행할 수 없다.     |

## 10. 프록시 서버(Proxy Server)

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/2/27/Open_proxy_h2g2bob.svg/350px-Open_proxy_h2g2bob.svg.png)

* 클라이언트가 자신을 통해서 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해 주는 컴퓨터나 프로그램을 가리킨다.

* 서버와 클라이언트 사이에서 중계기로서 대리로 통신을 수행하는 기능을 가리켜 프록시, 그 중계 기능을 하는 것을 프록시 서버라 한다.

* 프록시 서버는 프록시 서버에 요청된 내용들을 캐시를 이용해 저장해 둔다.

* 캐시 안에 있는 정보를 요구하는 요청에 대해서는 원격 서버에 접속하여 데이터를 가져올 필요가 없게 됨으로써 전송 시간을 절약하고, 불필요하게 외부와 연결하지 않아도 된다.

* 외부와의 트래픽을 줄이게 됨으로써 네트워크 병목 현상을 방지하는 효과도 얻을 수 있게 된다.

  ### 목적

  * 익명으로 컴퓨터를 유지(보안을 위해)
  * 캐시를 사용하여 리소스로의 접근을 빠르게 하기 위해, 웹 프록시는 웹 서버로부터 웹 페이지를 캐시로 저장하는데 흔히 쓰인다.
  * 네트워크 서비스나 컨텐츠로의 접근 정책을 적용하기 위해(유해 사이트 차단)
  * 사용률을 기록하고 검사하기 위해(회사 인트라넷)
  * 보안 및 통제를 뚫고 나가기 위해
  * 바이러스 전파, 악성 루머 전파, 다른 정보들을 빼낼 목적으로
  * 역으로 IP추적을 당하지 않을 목적으로
  * 전달에 앞서 악성 코드를 목적으로 전달된 컨텐츠를 검사하기 위해
  * 밖으로 나가는 컨텐츠를 검사하기 위해(데이터 유출 보호)
  * 지역 제한을 우회하기 위해

## 11. 미들웨어(Middleware)

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/2/20/Middleware_Schema.svg/751px-Middleware_Schema.svg.png)

* 응용 소프트웨어가 운영 체제로 부터 제공 받는 서비스 이외에 추가적으로 이용할 수 있는 서비스를 제공하는 소프트웨어
* 데이터 베이스 시스템, 전자 통신 소프트웨어, 메시지 및 쿼리 처리 소프트웨어, MessageQ
* 미들웨어는 양 쪽을 연결하여 데이터를 주고 받을 수 있도록 중간에서 매개 역할을 하는 소프트웨어
* 네트워크를 통해서 연결된 여러 개의 컴퓨터에 많은 프로세스들에게 어떤 서비스를 사용할 수 있도록 연결해 주는 소프트웨어
* 3계층 클라이언트/서버 구조에서 미들웨어가 존재한다.
* 웹 브라우저에서 DB로 부터 데이터를 저장하거나 읽어올 수 있게 중간에 미들웨어가 존재하게 된다.
* 표준화된 인터페이스 제공 가능
* 다양한 환경 지원, 체계가 다른 업무와 상호 연동이 가능
* 분산된 업무를 동시에 처리 가능하여 자료의 일관성이 유지
* 부하의 분산이 가능
* 모든 비즈니스 로직을 서버에서 관리 하기 때문에 유지 보수가 간편해진다. 만약 변경 사항이 있는 경우에 오직 서버 측만 변경하기 때문에 유지 보수가 간편해지는 것이다.
* 확장성이 좋다.

### 종류

- [원격 프로시저 호출](https://ko.wikipedia.org/wiki/%EC%9B%90%EA%B2%A9_%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80_%ED%98%B8%EC%B6%9C) (Remote Procedure Call, 약칭 RPC) — 클라이언트가 원격에서 동작하는 프로시저를 호출하는 시스템. 동기 또는 비동기 지원.
- [메시지 지향 미들웨어](https://ko.wikipedia.org/wiki/%EB%A9%94%EC%8B%9C%EC%A7%80_%EC%A7%80%ED%96%A5_%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4) (Message Oriented Middleware, 약칭 MOM) — 클라이언트가 생성한 메시지는 저장소에 요청할 때 저장하면서, 다른 업무를 지속할 수 있도록 하는 비동기식 미들웨어.
- [ORB](https://ko.wikipedia.org/w/index.php?title=ORB_(%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4)&action=edit&redlink=1) (Object Request Broker) — 객체지향 시스템에서 객체 및 서비스를 요청하고 전송할 수 있도록 지원하는 미들웨어.
- [DB 접속 미들웨어](https://ko.wikipedia.org/w/index.php?title=DB_%EC%A0%91%EC%86%8D_%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4&action=edit&redlink=1) — 애플리케이션과 데이터베이스 서버를 연결해주는 미들웨어.

또다른 분류법 :

- [TP 모니터](https://ko.wikipedia.org/wiki/TP_%EB%AA%A8%EB%8B%88%ED%84%B0) (Transaction Processing(TP) monitor) — 분산 시스템의 애플리케이션을 지원하는 미들웨어. 주로 C/S 시스템에 사용됨.
- [웹 애플리케이션 서버](https://ko.wikipedia.org/wiki/%EC%9B%B9_%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98_%EC%84%9C%EB%B2%84) (Web Application Server) — 웹 애플리케이션을 지원하는 미들웨어.
- [엔터프라이즈 서비스 버스](https://ko.wikipedia.org/wiki/%EC%97%94%ED%84%B0%ED%94%84%EB%9D%BC%EC%9D%B4%EC%A6%88_%EC%84%9C%EB%B9%84%EC%8A%A4_%EB%B2%84%EC%8A%A4) (Enterprise Service Bus) — 메시지 기반으로 느슨한 결합형태의 표준 인터페이스 통신을 지원하는 미들웨어로 기업 안팎에 있는 모든 시스템 환경을 연동하는 미들웨어.

## 12. 서버 사이드(Server-side)

* 클라이언트-서버 구조의 서버 쪽에서 행해지는 처리

* MMORPG의 게임 캐릭터 정보와 아이템 정보 등

* 서버 관리자의 입장에서 데이터 위조의 가능성을 줄일 수 있다.

* 서버 쪽의 데이터가 확실한 진위이며 클라이언트 쪽에서 위조해서는 안 되는 민감한 데이터의 경우 서버 사이드로 처리해야 한다.(인터넷 뱅킹)

* 클라이언트 컴퓨터의 처리 부담이 줄어든다.

* 서버의 처리 부담이 커져 결과적으로 서버 비용이 늘어날 수도 있다.

* 서버 사이드 스크립트 언어 : 서버 사이드에서 실행되는 스크립트 언어

  .c, .jsp, .asp, .py, .js(node.js)

## 13. 클라이언트 사이드

* 클라이언트-서버 구조의 클라이언트 쪽에서 행해지는 처리
* MMORPG의 화려한 그래픽

## 14. 클러스터(Cluster)

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/4/40/Beowulf.png/1024px-Beowulf.png)

* 여러 대의 컴퓨터들이 연결되어 하나의 시스템처럼 동작하는 컴퓨터들의 집합
* 클러스터의 구성 요소들은 일반적으로 고속의 근거리 통신망으로 연결된다.
* 서버로 사용되는 노드에는 각각의 운영체제가 실행된다.
* 단일 컴퓨터보다 더 뛰어난 성능과 안정성을 제공하며, 비슷한 성능과 안정성을 제공하는 단일 컴퓨터보다 비용 면에서 훨씬 더 효율적이다.
* 컴퓨팅 노드들을 클러스터 미들웨어 라는 소프트웨어 계층에서 관리된다. 이 소프트웨어 계층은 노드의 상부층에 위치하여 사용자들이 단일 시스템 이미지 개념으로 하나의 커다란 컴퓨팅 단위로 처리할 수 있도록 한다.
* Load Balancing(작업 부하 분산) 클러스터는 시스템의 전반적인 성능을 향상시키기 위해 계산 부하량을 여러 노드에서 분담하여 병렬 처리하도록 구성하는 방식이다.
* 각기 다른 종류의 요구들을 각기 다른 노드에서 처리하도록 할당함으로써 전반적인 응답시간을 최소화 할 수 있다.
* High Avaliability(높은 가용성, HA) 클러스터는 시스템의 가용성을 높이기 위한 방법중의 하나
* 하나의 노드에 장애가 생겼을 때 연결된 다른 노드들의 컴퓨터가 서비스를 이어받아(Failover) 계속해서 서비스되도록 한다.
* 베오울프 시스템은 Master-Slave 서버들로 구성되어 있다.
* 주 서버는 컴퓨터의 일들을 나누고 관리하며, 종속 서버는 일을 처리한다.
* 애플리케이션 프로그램은 주 서버와 통신할 뿐 종속 서버와는 통신하지 않는다.
* 많은 클라이언트들의 요청을 동시에 처리하기 위해서 많은 서버들을 네트워크로 연결하여 클러스터 형태로 구성한다.

## 15. 클라이언트-서버 모델

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c9/Client-server-model.svg/500px-Client-server-model.svg.png)

* 서비스 요청자인 클라이언트와 서비스 자원의 제공자인 서버 간의 작업을 분리해주는 분산 애플리케이션 구조이자 네트워크 아키텍처를 나타낸다.
* 웹 시스템도 확장된 클라이언트 서버 시스템으로 분류되나, 일반적으로 클라이언트 서버 시스템이라고 하면 웹 시스템이 나오기 이전의, 사용자 PC에는 클라이언트가 설치되어 화면을 처리하고 서버에서는 자료를 처리하는 시스템을 말한다.

## 16. 다층 구조(Multi-tier Architecutre, n-tier Arcjotercutre)

* 비즈니스 로직을 완전히 분리하여 데이터 베이스 시스템과 클라이언트 사이에 배치한 클라이언트 서버 시스템의 일종이다.

* 사용자와 데이터 베이스간 데이터 요구 세비스에 미들웨어를 이용하는 것이 예이다. 일반적으로 3층 구조(3-tier)가 널리 쓰인다.

  ### 3층 구조(3-Tier)

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/5/51/Overview_of_a_three-tier_application_vectorVersion.svg/593px-Overview_of_a_three-tier_application_vectorVersion.svg.png)

* 3층 이란 사용자 인터페이스, 비즈니스 로직, 데이터 베이스를 말하며, 이들을 각각 독립된 모듈로 개발하고 유지하는 구조로, 일반적으로 이들은 각각 다른 플랫폼 상에서 구동된다.
* 2층 구조의 제한을 극복하기 위해 탄생한 구조
* 사용자 인터페이스 환경과 데이터 베이스 관리 서버 환경 사이의 중간층이 추가된 구조이다.
* 중간층의 구현은 트랜잭션 처리 모니터, 메시지 서버, 응용 서버 등 여러 가지 방법으로 구축될 수 있다.
* 중간층은 데이터 베이스의 다단계나 응용 프로그램의 실행 또는 사용자 요구 분산을 위한 큐잉을 수행할 수 있다.
* 프레젠테이션 계층 : 응용 프로그램의 최상위에 위치하고 있는데 이는 서로 다른 층에 있는 데이터 등과 커뮤니테이션을 한다.
* 애플리케이션 계층 : 비즈니스 로직, 트랜잭션 계층이라고도 한다. 
  * 비스니스 로직은 워크스테이션으로부터의 클라이언트 요청에 대해 마치 서버처럼 행동한다. 그것은 차례로 어떤 데이터가 필요한지를 결정한다.
  * 메인프레임 컴퓨터 상에 위치하고 있을 세 번째 계층의 프로그램에 대해서는 마치 클라이언트처럼 행동한다.
* 데이터 계층 : 데이터 베이스와 그것에 액세스해서 읽거나 쓰는 것을 관리하는 프로그램을 포함한다.

## 17. 자바 스크립트

## 18. Node.js

## 19. 자바 스크립트 엔진

## 20. 크롬 V8

## 21. 서버 사이드 렌더링

## 22. 클라이언트 사이드 렌더링

## 23. 리버스 프록시(Reverse Proxy)

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/6/67/Reverse_proxy_h2g2bob.svg/400px-Reverse_proxy_h2g2bob.svg.png)

* 컴퓨터 네트워크에서 한 대 이상의 서버로부터 클라이언트 중간에 자원을 검색하는 프록시 서버의 일종
* 이러한 자원들은 마치 웹 서버 자체에서 기원한 것처럼 클라이언트로 반환된다.
* 관련 서버가 클라이언트에 의해 접속되는 중간 매개체이다.
* 리버스 프록시는 인터넷으로부터 요청을 받아와서 이것들을 내부망의 서버로 포워드한다.
* 프록시에 요청을 하는 대상은 내부망을 인지하지 못할 수 있다.
* 대중적인 웹 서버들은 Reverse Proxy 기능을 사용하는 일이 잦으며 약화된 HTTP 기능의 애플리케이션 프레임워크를 보호한다.
* 리버스 프록시로 서비스 제공시 WAS에서 REMOTE_ADDR을 사용하면 Reverse Proxy 서버의 IP를 얻게 된다. 따라서 프록시 환경에서 Client IP를 얻기 위한 X-Forwarded-For(XFF) http header를 참고해서 XFF를 사용해야 한다.
* Reverse Proxy는 인터넷 사용자의 공격으로부터 내부 서버를 보호나는 보안 기능을 수행함으로써 네트워크 DMZ에서 회사 인트라넷의 HTTP서버를 보호하기 위해 배치되는 보안 디바이스이다.
* 내부 네트워크에 대한 단일 액세스 지점을 제공하여 내부 HTTP 서버를 보호한다.
* 관리자는 Reverse Proxy Server의 인증 및 액세스 제어 기능을 사용하여 내부 Server에 액세스할 수 있는 사용자를 제어하고 각 개별 사용자가 액세스할 수 있는 서버를 제어할 수 있습니다.
* 인트라넷 서버에 대한 모든 트래픽은 단일 네트워크 주소(Reverse Proxy 서버의 주소)에 대해 지정된 것으로 나타납니다.
* Reverse Proxy 서버가 배치되면 Reverse Proxy 서버와 연관된 URL만 웹 브라우저 사용자에게 공개되고, 인터넷 사용자는 이 URL을 사용하여 Reverse Proxy 서버에 액세스 한다.
* 관리자는 Reverse Proxy 서버에서 이러한 리디렉션을 가능하게 하는 URL 맵핑 구성을 수행한다.
* 내부 서버에서 인터넷 사용자에게 전송된 모든 트래픽은 단일 네트워크 주소에서 시작된 것으로 나타난다.
* 출저 : https://www.ibm.com/support/knowledgecenter/ko/SSKTXQ_9.0.0/admin/config/st_adm_port_rvprxy_overview_c.html, https://www.lesstif.com/pages/viewpage.action?pageId=21430345

----

모든 자료는 위키 백과 https://ko.wikipedia.org/wiki 에서 참조하였습니다. 